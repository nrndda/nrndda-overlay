diff --git a/.gitignore b/.gitignore
index 567609b..ec2f521 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
+api/opencl/khronos/icd/
 build/
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 63df360..b880a86 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -5,6 +5,9 @@ if (POLICY CMP0048)
   set(PROJ_VERSION VERSION 1.5.0)
 endif()
 
+# FIXME: Remove following line after enabling COMGR by default
+set(USE_COMGR_LIBRARY "no" CACHE STRING "Do not enable COMGR by default")
+
 # Build ROCm-OpenCL with ccache if the package is present.
 set(ROCM_OPENCL_CCACHE_BUILD OFF CACHE BOOL "Set to ON for a ccache enabled build")
 if(ROCM_OPENCL_CCACHE_BUILD)
@@ -14,140 +17,149 @@ if(ROCM_OPENCL_CCACHE_BUILD)
   else()
     message(FATAL_ERROR "Unable to find the program ccache. Set ROCM_OPENCL_CCACHE_BUILD to OFF")
   endif()
-  set(LLVM_CCACHE_BUILD ON CACHE BOOL "")
-  set(ROCM_DEVICE_LIBS_CCACHE_BUILD ON CACHE BOOL "")
-  set(ROCM_OPENCL_DRIVER_CCACHE_BUILD ON CACHE BOOL "")
+
+  # FIXME: Remove following if block after enabling COMGR by default
+  if (${USE_COMGR_LIBRARY} STREQUAL "no")
+    set(LLVM_CCACHE_BUILD ON CACHE BOOL "")
+    set(ROCM_DEVICE_LIBS_CCACHE_BUILD ON CACHE BOOL "")
+    set(ROCM_OPENCL_DRIVER_CCACHE_BUILD ON CACHE BOOL "")
+  endif() # if (${USE_COMGR_LIBRARY} STREQUAL "no")
 endif()
 
 project(OpenCL-ROCm)
 
-# Add path for custom modules
-set(CMAKE_MODULE_PATH
-  ${CMAKE_MODULE_PATH}
-  "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
-  "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules"
-  )
-
-set(LLVM_INCLUDE_TESTS OFF CACHE BOOL "")
-set(LLVM_BUILD_TOOLS OFF CACHE BOOL "")
-set(LLVM_INSTALL_TOOLCHAIN_ONLY ON CACHE BOOL "")
-set(LLVM_TARGETS_TO_BUILD "AMDGPU" CACHE STRING "")
-set(CLANG_ENABLE_ARCMT OFF CACHE BOOL "")
-set(CLANG_ENABLE_STATIC_ANALYZER OFF CACHE BOOL "")
-
-# override default option value in library and driver
-set(GENERIC_IS_ZERO ON CACHE BOOL ON FORCE)
-
-add_subdirectory(compiler/llvm EXCLUDE_FROM_ALL)
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake" "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules")
+set(OPENCL_ICD_LOADER_HEADERS_DIR "${CMAKE_CURRENT_SOURCE_DIR}/api/opencl/khronos/headers/opencl2.2" CACHE PATH "")
 
-find_package(LLVM REQUIRED CONFIG PATHS ${CMAKE_BINARY_DIR}/compiler/llvm NO_DEFAULT_PATH)
+find_package(ROCT REQUIRED)
+find_package(ROCR REQUIRED)
 
-list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
-include(AddLLVM)
+# FIXME: Remove following if block after enabling COMGR by default
+if (${USE_COMGR_LIBRARY} STREQUAL "no")
+  set(LLVM_INCLUDE_TESTS OFF CACHE BOOL "")
+  set(LLVM_BUILD_TOOLS OFF CACHE BOOL "")
+  set(LLVM_INSTALL_TOOLCHAIN_ONLY ON CACHE BOOL "")
+  set(LLVM_TARGETS_TO_BUILD "AMDGPU" CACHE STRING "")
+  set(CLANG_ENABLE_ARCMT OFF CACHE BOOL "")
+  set(CLANG_ENABLE_STATIC_ANALYZER OFF CACHE BOOL "")
+
+  # override default option value in library and driver
+  set(GENERIC_IS_ZERO ON CACHE BOOL ON FORCE)
+
+  add_subdirectory(compiler/llvm EXCLUDE_FROM_ALL)
+
+  find_package(LLVM REQUIRED CONFIG PATHS ${CMAKE_BINARY_DIR}/compiler/llvm NO_DEFAULT_PATH)
+
+  list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
+  include(AddLLVM)
+
+  add_definitions(${LLVM_DEFINITIONS})
+  # TODO: add find_package for Clang and lld, and also use LLVM/Clang variables got from their config
+  include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/include)
+  include_directories(${CMAKE_BINARY_DIR}/compiler/llvm/tools/clang/include)
+  include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/tools/lld/include)
+
+  # TODO: move AMDGPU.h header to include folder
+  include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/lib/Target/AMDGPU)
+  include_directories(${CMAKE_BINARY_DIR}/compiler/llvm/lib/Target/AMDGPU)
+
+  set(BUILD_HC_LIB OFF CACHE BOOL "")
+  set(ROCM_DEVICELIB_INCLUDE_TESTS OFF CACHE BOOL "")
+  set(AMDGCN_TARGETS_LIB_LIST "AMDGCN_LIB_TARGETS")
+  set(AMDGCN_TARGETS_LIB_DEPS "AMDGCN_DEP_TARGETS")
+  set(AMDGPU_TARGET_TRIPLE "amdgcn-amd-amdhsa")
+  add_subdirectory(library/amdgcn EXCLUDE_FROM_ALL)
+  add_subdirectory(compiler/driver EXCLUDE_FROM_ALL)
 
-add_definitions(${LLVM_DEFINITIONS})
-# TODO: add find_package for Clang and lld, and also use LLVM/Clang variables got from their config
-include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/include)
-include_directories(${CMAKE_BINARY_DIR}/compiler/llvm/tools/clang/include)
-include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/tools/lld/include)
+  install(PROGRAMS $<TARGET_FILE:clang> $<TARGET_FILE:lld>
+          DESTINATION bin/x86_64
+          COMPONENT DEV)
 
-# TODO: move AMDGPU.h header to include folder
-include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/lib/Target/AMDGPU)
-include_directories(${CMAKE_BINARY_DIR}/compiler/llvm/lib/Target/AMDGPU)
+  foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
+    get_target_property(lib_file_name ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_NAME)
+    get_target_property(lib_file_path ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_DIRECTORY)
+    install(FILES ${lib_file_path}/${lib_file_name}.amdgcn.bc
+          DESTINATION lib/x86_64/bitcode
+          COMPONENT DEV)
+  endforeach()
+endif() # if (${USE_COMGR_LIBRARY} STREQUAL "no")
 
 if(${USE_COMGR_LIBRARY} MATCHES "yes")
   set(COMGR_DYN_DLL "yes")
-  add_definitions(-DCOMGR_DYN_DLL="yes")
-  include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/include)
+  add_definitions(-DCOMGR_DYN_DLL)
   add_definitions(-DUSE_COMGR_LIBRARY)
-else()
-  add_subdirectory(compiler/driver EXCLUDE_FROM_ALL)
 endif()
 
-set(BUILD_HC_LIB OFF CACHE BOOL "")
-set(ROCM_DEVICELIB_INCLUDE_TESTS OFF CACHE BOOL "")
-set(AMDGCN_TARGETS_LIB_LIST "AMDGCN_LIB_TARGETS")
-set(AMDGCN_TARGETS_LIB_DEPS "AMDGCN_DEP_TARGETS")
-set(AMDGPU_TARGET_TRIPLE "amdgcn-amd-amdhsa")
-add_subdirectory(library/amdgcn EXCLUDE_FROM_ALL)
-
+add_subdirectory(api/opencl/amdocl)
 add_subdirectory(compiler/lib/loaders/elf/utils/libelf)
-
-find_package(ROCT REQUIRED)
-find_package(ROCR REQUIRED)
 add_subdirectory(runtime)
+add_subdirectory(tools/clinfo)
 
-set(OPENCL_INCLUDE_DIRS
-  ${CMAKE_SOURCE_DIR}/api/opencl/khronos/headers
-  ${CMAKE_SOURCE_DIR}/api/opencl/khronos/headers/opencl2.2)
-
-add_subdirectory(api/opencl/amdocl)
+set(BUILD_SHARED_LIBS "Build shared libs" ON)
 add_subdirectory(api/opencl/khronos/icd)
 
-add_subdirectory(tools/clinfo)
+###--- Packaging ------------------------------------------------------------###
 
-install(PROGRAMS $<TARGET_FILE:clang> $<TARGET_FILE:lld>
+# MAIN package
+install(PROGRAMS $<TARGET_FILE:clinfo>
         DESTINATION bin/x86_64
-        COMPONENT libraries)
-
+        COMPONENT MAIN)
+install(PROGRAMS $<TARGET_FILE:amdocl64>
+        DESTINATION lib/x86_64
+        COMPONENT MAIN)
 install(PROGRAMS $<TARGET_FILE:OpenCL>
         DESTINATION lib/x86_64
-        COMPONENT applications)
-
-install(PROGRAMS $<TARGET_LINKER_FILE:OpenCL>
+        COMPONENT MAIN)
+install(PROGRAMS $<TARGET_SONAME_FILE:OpenCL>
         DESTINATION lib/x86_64
-        COMPONENT libraries)
+        COMPONENT MAIN)
 
-install(DIRECTORY
-        "${CMAKE_CURRENT_SOURCE_DIR}/api/opencl/khronos/headers/opencl2.2/CL"
+# DEV package
+install(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/api/opencl/khronos/headers/opencl2.2/CL"
         DESTINATION include
-        COMPONENT libraries
+        COMPONENT DEV
         USE_SOURCE_PERMISSIONS
+        PATTERN cl_d3d10.h EXCLUDE
+        PATTERN cl_d3d11.h EXCLUDE
+        PATTERN cl_dx9_media_sharing.h EXCLUDE
         PATTERN cl_egl.h EXCLUDE)
+install(PROGRAMS $<TARGET_LINKER_FILE:OpenCL>
+        DESTINATION lib/x86_64
+        COMPONENT DEV)
+
+# Generic CPACK variables
+set(CPACK_GENERATOR "DEB;RPM" CACHE STRING "Default packaging generators")
+
+set(CPACK_PACKAGE_CONTACT "Advanced Micro Devices Inc.")
+set(CPACK_PACKAGE_VENDOR "AMD")
+set(CPACK_PACKAGING_INSTALL_PREFIX "/opt/rocm/opencl")
+
+set(CPACK_PACKAGE_VERSION_MAJOR "1")
+set(CPACK_PACKAGE_VERSION_MINOR "2")
+set(CPACK_PACKAGE_VERSION_PATCH "0")
+
+# Debian CPACK variables
+set(CPACK_DEB_COMPONENT_INSTALL ON)
+
+set(CPACK_DEBIAN_MAIN_FILE_NAME "rocm-opencl-1.2.0.deb")
+set(CPACK_DEBIAN_MAIN_PACKAGE_NAME "rocm-opencl")
+set(CPACK_DEBIAN_MAIN_PACKAGE_CONTROL_EXTRA "${CMAKE_CURRENT_SOURCE_DIR}/DEB/postinst;${CMAKE_CURRENT_SOURCE_DIR}/DEB/prerm")
+
+set(CPACK_DEBIAN_DEV_FILE_NAME "rocm-opencl-dev-1.2.0.deb")
+set(CPACK_DEBIAN_DEV_PACKAGE_NAME "rocm-opencl-dev")
+set(CPACK_DEBIAN_DEV_PACKAGE_DEPENDS "rocm-opencl")
+
+# RPM CPACK variables
+set(CPACK_RPM_COMPONENT_INSTALL ON)
+
+set(CPACK_RPM_MAIN_FILE_NAME "rocm-opencl-1.2.0.rpm")
+set(CPACK_RPM_MAIN_PACKAGE_NAME "rocm-opencl")
+set(CPACK_RPM_MAIN_POST_INSTALL_SCRIPT_FILE "${CMAKE_CURRENT_SOURCE_DIR}/RPM/rpm_post")
+set(CPACK_RPM_MAIN_POST_UNINSTALL_SCRIPT_FILE "${CMAKE_CURRENT_SOURCE_DIR}/RPM/rpm_postun")
+
+set(CPACK_RPM_DEV_FILE_NAME "rocm-opencl-devel-1.2.0.rpm")
+set(CPACK_RPM_DEV_PACKAGE_NAME "rocm-opencl-devel")
+set(CPACK_RPM_DEV_PACKAGE_DEPENDS "rocm-opencl")
 
-foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
-  get_target_property(lib_file_name ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_NAME)
-  get_target_property(lib_file_path ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_DIRECTORY)
-  install(FILES ${lib_file_path}/${lib_file_name}.amdgcn.bc
-        DESTINATION lib/x86_64/bitcode
-        COMPONENT libraries)
-endforeach()
-
-## CPack standard variables
-set ( CPACK_PACKAGE_NAME "rocm-opencl" )
-set ( CPACK_PACKAGE_FILE_NAME "rocm-opencl-1.2.0" )
-set ( CPACK_PACKAGE_VENDOR "AMD" )
-set ( CPACK_PACKAGE_VERSION_MAJOR "1" )
-set ( CPACK_PACKAGE_VERSION_MINOR "2" )
-set ( CPACK_PACKAGE_VERSION_PATCH "0" )
-set ( CPACK_PACKAGE_CONTACT "Advanced Micro Devices Inc." )
-set ( CPACK_DEBIAN_PACKAGE_HOMEPAGE "https://github.com/RadeonOpenCompute/ROCm-OpenCL-Runtime" )
-
-set ( CPACK_GENERATOR RPM DEB )
-set ( CPACK_PACKAGING_INSTALL_PREFIX "/opt/rocm/opencl" )
-
-## Debian package values
-
-set ( CPACK_DEBIAN_PACKAGE_MAINTAINER "AMD" )
-set ( CPACK_DEBIAN_PACKAGE_DEPENDS "" )
-set ( CPACK_DEB_COMPONENT_INSTALL ON)
-set ( CPACK_DEBIAN_applications_PACKAGE_NAME "rocm-opencl" )
-set ( CPACK_DEBIAN_applications_FILE_NAME "rocm-opencl-1.2.0.deb" )
-set ( CPACK_DEBIAN_libraries_PACKAGE_NAME "rocm-opencl-dev" )
-set ( CPACK_DEBIAN_libraries_FILE_NAME "rocm-opencl-dev-1.2.0.deb" )
-set ( CPACK_DEBIAN_libraries_PACKAGE_DEPENDS "rocm-opencl" )
-set ( CPACK_DEBIAN_applications_PACKAGE_CONTROL_EXTRA "${CMAKE_CURRENT_SOURCE_DIR}/DEB/postinst;${CMAKE_CURRENT_SOURCE_DIR}/DEB/prerm" )
-
-## RPM package values
-
-set ( CPACK_RPM_COMPONENT_INSTALL ON)
-set ( CPACK_RPM_applications_PACKAGE_NAME "rocm-opencl" )
-set ( CPACK_RPM_applications_FILE_NAME "rocm-opencl-1.2.0.rpm" )
-set ( CPACK_RPM_libraries_PACKAGE_NAME "rocm-opencl-devel" )
-set ( CPACK_RPM_libraries_FILE_NAME "rocm-opencl-devel-1.2.0.rpm" )
-set ( CPACK_RPM_libraries_PACKAGE_DEPENDS "rocm-opencl" )
-set ( CPACK_RPM_applications_POST_INSTALL_SCRIPT_FILE "${CMAKE_CURRENT_SOURCE_DIR}/RPM/rpm_post" )
-set ( CPACK_RPM_applications_POST_UNINSTALL_SCRIPT_FILE "${CMAKE_CURRENT_SOURCE_DIR}/RPM/rpm_postun" )
-
-set ( CPACK_COMPONENTS_ALL applications libraries )
-include ( CPack )
+set(CPACK_COMPONENTS_ALL MAIN DEV)
+include(CPack)
diff --git a/api/opencl/amdocl/CMakeLists.txt b/api/opencl/amdocl/CMakeLists.txt
index 642ce8c..8ea8517 100644
--- a/api/opencl/amdocl/CMakeLists.txt
+++ b/api/opencl/amdocl/CMakeLists.txt
@@ -16,6 +16,11 @@ if(CMAKE_BUILD_TYPE MATCHES "^Debug$")
   add_definitions(-DDEBUG)
 endif()
 
+include_directories(${ROCR_INCLUDES})
+if (DEFINED LLVM_INCLUDES AND NOT ${LLVM_INCLUDES} STREQUAL "")
+  include_directories(${LLVM_INCLUDES})
+endif() # if (DEFINED LLVM_INCLUDES AND NOT ${LLVM_INCLUDES} STREQUAL "")
+
 include_directories(${CMAKE_SOURCE_DIR}/runtime)
 include_directories(${CMAKE_SOURCE_DIR}/api/opencl)
 include_directories(${CMAKE_SOURCE_DIR}/api/opencl/khronos)
@@ -77,4 +82,3 @@ if(${USE_COMGR_LIBRARY} MATCHES "yes")
 else()
   target_link_libraries(amdocl64 opencl_driver oclelf pthread dl ${ROCT_LIBRARIES} ${ROCR_LIBRARIES})
 endif()
-install(TARGETS amdocl64 LIBRARY DESTINATION lib/x86_64 COMPONENT applications)
diff --git a/api/opencl/amdocl/cl_execute.cpp b/api/opencl/amdocl/cl_execute.cpp
index 0336353..ee799e6 100644
--- a/api/opencl/amdocl/cl_execute.cpp
+++ b/api/opencl/amdocl/cl_execute.cpp
@@ -10,7 +10,7 @@
 #include "platform/program.hpp"
 #include "os/os.hpp"
 
-#include <icd/icd_dispatch.h>
+#include <icd/loader/icd_dispatch.h>
 
 /*! \addtogroup API
  *  @{
diff --git a/api/opencl/amdocl/cl_icd.cpp b/api/opencl/amdocl/cl_icd.cpp
index 71b886c..7e4e317 100644
--- a/api/opencl/amdocl/cl_icd.cpp
+++ b/api/opencl/amdocl/cl_icd.cpp
@@ -10,7 +10,7 @@
 #include "cl_d3d11_amd.hpp"
 #endif  //_WIN32
 
-#include <icd/icd_dispatch.h>
+#include <icd/loader/icd_dispatch.h>
 
 #include <mutex>
 
diff --git a/compiler/lib/utils/target_mappings.h b/compiler/lib/utils/target_mappings.h
deleted file mode 100644
index c57eea6..0000000
--- a/compiler/lib/utils/target_mappings.h
+++ /dev/null
@@ -1,18 +0,0 @@
-//
-// Copyright (c) 2011 Advanced Micro Devices, Inc. All rights reserved.
-//
-// This is a compatibility header file. Either define the version
-// of the compiler library to use or include the version specific
-// header file directly.
-#ifndef TARGET_MAPPINGS_H_
-#define TARGET_MAPPINGS_H_
-
-#include "v0_8/target_mappings.h"
-
-#define X86TargetMapping X86TargetMapping_0_8
-#define X64TargetMapping X64TargetMapping_0_8
-#define AMDILTargetMapping AMDILTargetMapping_0_8
-#define HSAILTargetMapping HSAILTargetMapping_0_8
-#define AMDIL64TargetMapping AMDIL64TargetMapping_0_8
-#define HSAIL64TargetMapping HSAIL64TargetMapping_0_8
-#endif // TARGET_MAPPINGS_H_
diff --git a/compiler/lib/utils/v0_8/libUtils.cpp b/compiler/lib/utils/v0_8/libUtils.cpp
deleted file mode 100644
index 7836e21..0000000
--- a/compiler/lib/utils/v0_8/libUtils.cpp
+++ /dev/null
@@ -1,1141 +0,0 @@
-//
-// Copyright (c) 2011 Advanced Micro Devices, Inc. All rights reserved.
-//
-
-#include "api/v0_8/aclValidation.h"
-#include "libUtils.h"
-#include "bif/bifbase.hpp"
-#include "utils/target_mappings.h"
-#include "utils/versions.hpp"
-#include "utils/options.hpp"
-#include <cstring>
-#include "bif/bif.hpp"
-extern aclBinary* constructBinary(size_t struct_version,
-    const aclTargetInfo *target,
-    const aclBinaryOptions *opts);
-
-static const std::string sgfx700 = "AMD:AMDGPU:7:0:0";
-static const std::string sgfx701 = "AMD:AMDGPU:7:0:1";
-static const std::string sgfx800 = "AMD:AMDGPU:8:0:0";
-static const std::string sgfx801 = "AMD:AMDGPU:8:0:1";
-static const std::string sgfx802 = "AMD:AMDGPU:8:0:2";
-static const std::string sgfx803 = "AMD:AMDGPU:8:0:3";
-static const std::string sgfx804 = "AMD:AMDGPU:8:0:4";
-static const std::string sgfx810 = "AMD:AMDGPU:8:1:0";
-static const std::string sgfx900 = "AMD:AMDGPU:9:0:0";
-static const std::string sgfx901 = "AMD:AMDGPU:9:0:1";
-static const std::string sgfx902 = "AMD:AMDGPU:9:0:2";
-static const std::string sgfx903 = "AMD:AMDGPU:9:0:3";
-static const std::string sgfx904 = "AMD:AMDGPU:9:0:4";
-static const std::string sgfx905 = "AMD:AMDGPU:9:0:5";
-static const std::string sgfx906 = "AMD:AMDGPU:9:0:6";
-static const std::string sgfx907 = "AMD:AMDGPU:9:0:7";
-
-static const std::string legacyLibName = LINUX_ONLY("lib") "amdocl12cl" LP64_SWITCH(LINUX_SWITCH("32", ""), "64") LINUX_SWITCH(".so", ".dll");
-
-// Utility function to set a flag in option structure
-// of the aclDevCaps.
-void
-setFlag(aclDevCaps *caps, compDeviceCaps option)
-{
-  assert((uint32_t)option < ((1 << FLAG_SHIFT_VALUE)  *FLAG_ARRAY_SIZE)
-    && "The index passed in is outside of the range of valid values!");
-  caps->flags[option >> FLAG_SHIFT_VALUE] |= FLAG_BITLOC(option);
-}
-
-// Utility function to flip a flag in option structure
-// of the aclDevCaps.
-void
-flipFlag(aclDevCaps *caps, compDeviceCaps option)
-{
-  assert((uint32_t)option < ((1 << FLAG_SHIFT_VALUE)  *FLAG_ARRAY_SIZE)
-    && "The index passed in is outside of the range of valid values!");
-  caps->flags[option >> FLAG_SHIFT_VALUE] ^= FLAG_BITLOC(option);
-}
-
-// Utility function to clear a flag in option structure
-// of the aclDevCaps.
-void
-clearFlag(aclDevCaps *caps, compDeviceCaps option)
-{
-  assert((uint32_t)option < ((1 << FLAG_SHIFT_VALUE)  *FLAG_ARRAY_SIZE)
-    && "The index passed in is outside of the range of valid values!");
-  caps->flags[option >> FLAG_SHIFT_VALUE] &= ~FLAG_BITLOC(option);
-}
-
-// Utility function to check that a flag in option structure
-// of the aclDevCaps is set.
-bool
-checkFlag(aclDevCaps *caps, compDeviceCaps option)
-{
-  assert((uint32_t)option < ((1 << FLAG_SHIFT_VALUE)  *FLAG_ARRAY_SIZE)
-    && "The index passed in is outside of the range of valid values!");
-  return ((uint32_t)(caps->flags[option >> FLAG_SHIFT_VALUE]
-      & FLAG_BITLOC(option))) == (uint32_t)FLAG_BITLOC(option);
-}
-void setEncryptCaps(aclDevCaps_0_8 *ptr)
-{
-  clearFlag(ptr, capSaveSOURCE);
-  clearFlag(ptr, capSaveLLVMIR);
-  clearFlag(ptr, capSaveCG);
-  clearFlag(ptr, capSaveSPIR);
-  clearFlag(ptr, capSaveAMDIL);
-  clearFlag(ptr, capSaveHSAIL);
-  clearFlag(ptr, capSaveDISASM);
-  clearFlag(ptr, capSaveAS);
-  setFlag(ptr, capSaveEXE);
-  setFlag(ptr, capEncrypted);
-}
-void setOptionCaps(amd::option::Options *opts, aclDevCaps_0_8 *ptr)
-{
-#define COND_SET_FLAG(A) \
-      (((opts)->oVariables->Bin##A) ? setFlag(ptr, capSave##A) : clearFlag(ptr, capSave##A))
-      COND_SET_FLAG(SOURCE);
-      COND_SET_FLAG(LLVMIR);
-      COND_SET_FLAG(CG);
-      COND_SET_FLAG(DISASM);
-      COND_SET_FLAG(AMDIL);
-      COND_SET_FLAG(HSAIL);
-      COND_SET_FLAG(AS);
-      COND_SET_FLAG(SPIR);
-      COND_SET_FLAG(EXE);
-
-#undef COND_SET_FLAG
-}
-
-aclBIF *aclutGetBIF(aclBinary *binary)
-{
-  aclBIF *bif = NULL;
-  if (binary->struct_size == sizeof(aclBinary_0_8)) {
-    bif = reinterpret_cast<aclBinary_0_8*>(binary)->bin;
-  } else if (binary->struct_size == sizeof(aclBinary_0_8_1)) {
-    bif = reinterpret_cast<aclBinary_0_8_1*>(binary)->bin;
-  } else {
-    assert(!"Binary format not supported!");
-    bif = reinterpret_cast<aclBinary*>(binary)->bin;
-  }
-  return bif;
-}
-
-aclOptions *aclutGetOptions(aclBinary *binary)
-{
-  aclOptions *opt = NULL;
-  if (binary->struct_size == sizeof(aclBinary_0_8)) {
-    opt = reinterpret_cast<aclBinary_0_8*>(binary)->options;
-  } else if (binary->struct_size == sizeof(aclBinary_0_8_1)) {
-    opt = reinterpret_cast<aclBinary_0_8_1*>(binary)->options;
-  } else {
-    assert(!"Binary format not supported!");
-    opt = binary->options;
-  }
-  return opt;
-}
-
-aclBinaryOptions *aclutGetBinOpts(aclBinary *binary)
-{
-  aclBinaryOptions *opt = NULL;
-  if (binary->struct_size == sizeof(aclBinary_0_8)) {
-    opt = reinterpret_cast<aclBinaryOptions*>(
-        &reinterpret_cast<aclBinary_0_8*>(binary)->binOpts);
-  } else if (binary->struct_size == sizeof(aclBinary_0_8_1)) {
-    opt = &reinterpret_cast<aclBinary_0_8_1*>(binary)->binOpts;
-  } else {
-    assert(!"Binary format not supported!");
-    opt = &binary->binOpts;
-  }
-  return opt;
-}
-
-aclTargetInfo *aclutGetTargetInfo(aclBinary *binary)
-{
-  aclTargetInfo *tgt = NULL;
-  if (binary->struct_size == sizeof(aclBinary_0_8)) {
-    tgt = &reinterpret_cast<aclBinary_0_8*>(binary)->target;
-  } else if (binary->struct_size == sizeof(aclBinary_0_8_1)) {
-    tgt = &reinterpret_cast<aclBinary_0_8_1*>(binary)->target;
-  } else {
-    assert(!"Binary format not supported!");
-    tgt = &binary->target;
-  }
-  return tgt;
-}
-
-aclDevCaps* aclutGetCaps(aclBinary *binary)
-{
-  aclDevCaps *caps = NULL;
-  if (binary->struct_size == sizeof(aclBinary_0_8)) {
-    caps = &reinterpret_cast<aclBinary_0_8*>(binary)->caps;
-  } else if (binary->struct_size == sizeof(aclBinary_0_8_1)) {
-    caps = &reinterpret_cast<aclBinary_0_8_1*>(binary)->caps;
-  } else {
-    assert(!"Binary format not supported!");
-    caps = &binary->caps;
-  }
-  return caps;
-}
-// Helper function that returns the
-// allocation function from the binary.
-AllocFunc
-aclutAlloc(const aclBinary *bin)
-{
-  size_t size = (bin ? bin->struct_size : 0);
-  AllocFunc m = NULL;
-  switch(size) {
-    case 0:
-    case sizeof(aclBinary_0_8):
-      break;
-    case sizeof(aclBinary_0_8_1):
-      m = reinterpret_cast<const aclBinary_0_8_1*>(bin)->binOpts.alloc;
-      break;
-    default:
-      assert(!"Found an unsupported binary!");
-      m = bin->binOpts.alloc;
-      break;
-  }
-  return (m) ? m : &::malloc;
-}
-
-// Helper function that returns the
-// allocation function from the compiler.
-AllocFunc
-aclutAlloc(const aclCompiler *bin)
-{
-  size_t size = (bin ? bin->struct_size : 0);
-  AllocFunc m = NULL;
-  switch(size) {
-    case 0:
-    case sizeof(aclCompilerHandle_0_8):
-      break;
-    case sizeof(aclCompilerHandle_0_8_1):
-      m = reinterpret_cast<const aclCompilerHandle_0_8_1*>(bin)->alloc;
-      break;
-    default:
-      assert(!"Found an unsupported compiler!");
-      m = bin->alloc;
-      break;
-  }
-  return (m) ? m : &::malloc;
-}
-
-AllocFunc
-aclutAlloc(const aclCompilerOptions *opts)
-{
-  size_t size = (opts ? opts->struct_size : 0);
-  AllocFunc m = NULL;
-  switch (size) {
-    case 0:
-    case sizeof(aclCompilerOptions_0_8):
-      break;
-    case sizeof(aclCompilerOptions_0_8_1):
-      m = reinterpret_cast<const aclCompilerOptions_0_8_1*>(opts)->alloc;
-      break;
-    default:
-      assert(!"Found an unsupported compiler options struct!");
-      m = opts->alloc;
-      break;
-  }
-  return (m) ? m : &::malloc;
-}
-
-
-// Helper function that returns the
-// de-allocation function from the compiler.
-FreeFunc
-aclutFree(const aclCompiler *bin)
-{
-  size_t size = (bin ? bin->struct_size : 0);
-  FreeFunc f = NULL;
-  switch(size) {
-    case 0:
-    case sizeof(aclCompilerHandle_0_8):
-      break;
-    case sizeof(aclCompilerHandle_0_8_1):
-      f = reinterpret_cast<const aclCompilerHandle_0_8_1*>(bin)->dealloc;
-      break;
-    default:
-      assert(!"Found an unsupported compiler!");
-      f = bin->dealloc;
-      break;
-  }
-  return (f) ? f : &::free;
-}
-
-// Helper function that returns the
-// de-allocation function from the binary.
-FreeFunc
-aclutFree(const aclBinary *bin)
-{
-  size_t size = (bin ? bin->struct_size : 0);
-  FreeFunc f = NULL;
-  switch(size) {
-    case 0:
-    case sizeof(aclBinary_0_8):
-      break;
-    case sizeof(aclBinary_0_8_1):
-      f = reinterpret_cast<const aclBinary_0_8_1*>(bin)->binOpts.dealloc;
-      break;
-    default:
-      assert(!"Found an unsupported binary!");
-      f = bin->binOpts.dealloc;
-      break;
-  }
-  return (f) ? f : &::free;
-}
-
-FreeFunc
-aclutFree(const aclCompilerOptions *opts)
-{
-  size_t size = (opts ? opts->struct_size : 0);
-  FreeFunc f = NULL;
-  switch (size) {
-    case 0:
-    case sizeof(aclCompilerOptions_0_8):
-      break;
-    case sizeof(aclCompilerOptions_0_8_1):
-      f = reinterpret_cast<const aclCompilerOptions_0_8_1*>(opts)->dealloc;
-      break;
-    default:
-      assert(!"Found an unsupported compiler options struct!");
-      f = opts->dealloc;
-      break;
-  }
-  return (f) ? f : &::free;
-}
-
-
-void
-aclutCopyBinOpts(aclBinaryOptions *dst, const aclBinaryOptions *src, bool is64)
-{
-  if (dst == src) return;
-  aclBinaryOptions_0_8 *dst08;
-  aclBinaryOptions_0_8_1 *dst081;
-  const aclBinaryOptions_0_8 *src08;
-  const aclBinaryOptions_0_8_1 *src081;
-  dst08 = reinterpret_cast<aclBinaryOptions_0_8*>(dst);
-  dst081 = reinterpret_cast<aclBinaryOptions_0_8_1*>(dst);
-  src08 = reinterpret_cast<const aclBinaryOptions_0_8*>(src);
-  src081 = reinterpret_cast<const aclBinaryOptions_0_8_1*>(src);
-  unsigned size = (src ? src->struct_size : 0);
-  switch (size) {
-    case 0:
-      switch (dst->struct_size) {
-        case sizeof(aclBinary_0_8):
-          dst08->elfclass = (is64) ? ELFCLASS64 : ELFCLASS32;
-          dst08->bitness = ELFDATA2LSB;
-          dst08->temp_file = "";
-          dst08->kernelArgAlign = 4;
-          break;
-        case sizeof(aclBinary_0_8_1):
-          dst081->elfclass = (is64) ? ELFCLASS64 : ELFCLASS32;
-          dst081->bitness = ELFDATA2LSB;
-          dst081->temp_file = "";
-          dst081->kernelArgAlign = 4;
-          dst081->alloc = &::malloc;
-          dst081->dealloc = &::free;
-          break;
-        default:
-          dst->elfclass = (is64) ? ELFCLASS64 : ELFCLASS32;
-          dst->bitness = ELFDATA2LSB;
-          dst->temp_file = "";
-          dst->kernelArgAlign = 4;
-          dst->alloc = &::malloc;
-          dst->dealloc = &::free;
-          break;
-       }
-      break;
-    case sizeof(aclBinaryOptions_0_8):
-      switch (dst->struct_size) {
-        case sizeof(aclBinaryOptions_0_8):
-          memcpy(dst08, src08, src08->struct_size);
-          break;
-        case sizeof(aclBinaryOptions_0_8_1):
-          dst081->elfclass = src08->elfclass;
-          dst081->bitness = src08->bitness;
-          dst081->temp_file = src08->temp_file;
-          dst081->kernelArgAlign = src08->kernelArgAlign;
-          dst081->alloc = &::malloc;
-          dst081->dealloc = &::free;
-          break;
-        default:
-          assert(!"aclBinary format is not supported!");
-          memcpy(dst, src08, src08->struct_size);
-          if (!dst->alloc) dst->alloc = &::malloc;
-          if (!dst->dealloc) dst->dealloc = &::free;
-      }
-      break;
-    case sizeof(aclBinaryOptions_0_8_1):
-      switch (dst->struct_size) {
-        case sizeof(aclBinary_0_8):
-          dst08->elfclass = src081->elfclass;
-          dst08->bitness = src081->bitness;
-          dst08->temp_file = src081->temp_file;
-          dst08->kernelArgAlign = src081->kernelArgAlign;
-          break;
-        case sizeof(aclBinaryOptions_0_8_1):
-          memcpy(dst081, src081, src081->struct_size);
-          if (!dst->alloc) dst->alloc = &::malloc;
-          if (!dst->dealloc) dst->dealloc = &::free;
-          break;
-        default:
-          assert(!"aclBinary format is not supported!");
-          memcpy(dst, src081, src081->struct_size);
-          if (!dst->alloc) dst->alloc = &::malloc;
-          if (!dst->dealloc) dst->dealloc = &::free;
-      }
-      break;
-    default:
-      assert(!"aclBinary format is not supported!");
-      memcpy(dst, src, src->struct_size);
-  }
-}
-
-acl_error
-aclutInsertKernelStatistics(aclCompiler *cl, aclBinary *bin)
-{
-    if (!aclValidateCompiler(cl, true)) {
-        return ACL_INVALID_COMPILER;
-    }
-    if (!aclValidateBinary(bin)) {
-        return ACL_INVALID_BINARY;
-    }
-    size_t len = 0;
-    acl_error err = ACL_SUCCESS;
-    const void *isa = aclExtractSection(cl, bin, &len, aclTEXT, &err);
-    if (err != ACL_SUCCESS)
-        return err;
-    aclTargetInfo *tgtInfo = aclutGetTargetInfo(bin);
-    const char* chipName = aclGetChip(*tgtInfo);
-    unsigned family = getFamilyEnum(tgtInfo);
-    unsigned chip = getChipEnum(tgtInfo);
-    // Non-GPU devices have family_enum set to 1 and do not qualify. Need to update.
-    if (family >= FAMILY_R600 &&
-	    family <= FAMILY_CZ) {
-	  aclKernelStats kstats = {0};
-      aclGetKstatsSI(isa, kstats);
-	  kstats.wavefrontsize = 64; // FIXME: Hardcoded for now.
-	  const oclBIFSymbolStruct* symbol = findBIF30SymStruct(symKernelStats);
-	  assert(symbol && "symbol not found");
-	  std::string symName = std::string(symbol->str[PRE]) + std::string(symbol->str[POST]);
-	  err = aclInsertSymbol(cl, bin, reinterpret_cast<void*>(&kstats), sizeof(kstats), aclKSTATS, symName.c_str());
-    }
-    return err;
-}
-
-std::string aclutGetCodegenName(const aclTargetInfo &tgtInfo)
-{
-  assert(tgtInfo.arch_id <= aclLast && "Unknown device id!");
-  const FamilyMapping *family = familySet + tgtInfo.arch_id;
-  if (!family) return "";
-
-  assert((tgtInfo.chip_id) < family->children_size && "Unknown family id!");
-  const TargetMapping *target = &family->target[tgtInfo.chip_id];
-  return (target) ? target->codegen_name : "";
-}
-
-void initElfDeviceCaps(aclBinary *elf)
-{
-  if (aclutGetCaps(elf)->encryptCode) {
-    setEncryptCaps(aclutGetCaps(elf));
-    return;
-  }
-  if (aclutGetOptions(elf)) {
-    setOptionCaps(reinterpret_cast<amd::option::Options*>(
-          aclutGetOptions(elf)), aclutGetCaps(elf));
-  }
-}
-
-const char *getDeviceName(const aclTargetInfo &target)
-{
-  if (target.chip_id) {
-    return aclGetChip(target);
-  } else if (target.arch_id) {
-    return aclGetArchitecture(target);
-  }
-  return NULL;
-}
-
-const TargetMapping& getTargetMapping(const aclTargetInfo &target)
-{
-  switch (target.arch_id) {
-  default:
-    break;
-  case aclX64:
-    return X64TargetMapping[target.chip_id];
-    break;
-  case aclX86:
-    return X86TargetMapping[target.chip_id];
-    break;
-  case aclHSAIL:
-    return HSAILTargetMapping[target.chip_id];
-    break;
-  case aclHSAIL64:
-    return HSAIL64TargetMapping[target.chip_id];
-    break;
-  case aclAMDIL:
-    return AMDILTargetMapping[target.chip_id];
-    break;
-  case aclAMDIL64:
-    return AMDIL64TargetMapping[target.chip_id];
-    break;
-  };
-  return UnknownTarget;
-}
-
-bool isChipSupported(const aclTargetInfo& target)
-{
-  if (!isValidTarget(target)) {
-    return false;
-  }
-  const TargetMapping& Mapping = getTargetMapping(target);
-  if (Mapping.family_enum == FAMILY_UNKNOWN) {
-    return false;
-  }
-  return Mapping.supported;
-}
-
-/*! Function that returns the library type from the TargetMapping table for
- *the specific target device id.
- */
-amd::LibrarySelector getLibraryType(const aclTargetInfo *target)
-{
-  const TargetMapping& Mapping = getTargetMapping(*target);
-  return Mapping.lib;
-}
-
-/*! Function that returns family_enum from the TargetMapping table for
- *the specific target device id.
- */
-unsigned getFamilyEnum(const aclTargetInfo *target)
-{
-  const TargetMapping& Mapping = getTargetMapping(*target);
-  return Mapping.family_enum;
-}
-
-/*! Function that returns chip_enum from the TargetMapping table for
- *the specific target device id.
- */
-unsigned getChipEnum(const aclTargetInfo *target)
-{
-  const TargetMapping& Mapping = getTargetMapping(*target);
-  return Mapping.chip_enum;
-}
-
-/*! Function that returns isa type name (compute capability) from
- *the TargetMapping table for the specific target device id.
- */
-const std::string &getIsaTypeName(const aclTargetInfo *target)
-{
-  switch (getIsaType(target)) {
-  default:  return sgfx700;
-  case 700: return sgfx700;
-  case 701: return sgfx701;
-  case 800: return sgfx800;
-  case 801: return sgfx801;
-  case 802: return sgfx802;
-  case 803: return sgfx803;
-  case 804: return sgfx804;
-  case 810: return sgfx810;
-  case 900: return sgfx900;
-  case 901: return sgfx901;
-  case 902: return sgfx902;
-  case 903: return sgfx903;
-  case 904: return sgfx904;
-  case 905: return sgfx905;
-  case 906: return sgfx906;
-  case 907: return sgfx907;
-  }
-}
-
-/*! Function that returns isa type (compute capability) from
- *the TargetMapping table for the specific target device id.
- */
-int getIsaType(const aclTargetInfo *target)
-{
-  const TargetMapping& Mapping = getTargetMapping(*target);
-  switch (Mapping.family_enum) {
-    default: return 700;
-    case FAMILY_KV:
-      switch (Mapping.chip_enum) {
-        default: return 700;
-        case KV_SPECTRE_A0:
-        case KV_SPOOKY_A0:
-        case KB_KALINDI_A0:
-        // ???
-        case ML_GODAVARI_A0: return 700;
-      }
-    case FAMILY_CI:
-      switch (Mapping.chip_enum) {
-        default: return 700;
-        case CI_BONAIRE_M_A0:
-        case CI_BONAIRE_M_A1: return 700;
-        case CI_HAWAII_P_A0: return 701;
-        case CI_TIRAN_P_A0:
-        case CI_MAUI_P_A0: return 700;
-      }
-    case FAMILY_VI:
-      switch (Mapping.chip_enum) {
-        default: return 800;
-        case VI_TONGA_P_A0:
-#if defined(BUILD_HSA_TARGET)
-        return 802; // Special case - Boltzmann Tonga
-          // Otherwise fall through
-#endif
-        case VI_ICELAND_M_A0: return 800;
-        case VI_FIJI_P_A0:
-        case VI_BAFFIN_M_A0:
-        case VI_BAFFIN_M_A1:
-        case VI_ELLESMERE_P_A0:
-        case VI_ELLESMERE_P_A1:
-        case VI_LEXA_V_A0:
-        case VI_POLARIS22_P_A0:
-#if defined(BUILD_HSA_TARGET)
-        return 803; // Special case - Boltzmann FIJI, BAFFIN, ELLESMERE, LEXA
-          // Otherwise fall through
-#else
-        return 804;
-#endif
-      }
-    case FAMILY_CZ:
-      switch (Mapping.chip_enum) {
-        default: return 801;
-        case CARRIZO_A0: return 801;
-        case STONEY_A0:  return 810;
-      }
-    case FAMILY_AI:
-      switch (Mapping.chip_enum) {
-        default: return 900;
-        case AI_GREENLAND_P_A0:
-        case AI_GREENLAND_P_A1: return Mapping.xnack_supported ? 901 : 900;
-        case AI_VEGA12_P_A0:    return Mapping.xnack_supported ? 905 : 904;
-        case AI_VEGA20_P_A0:    return Mapping.xnack_supported ? 907 : 906;
-      }
-    case FAMILY_RV:
-      switch (Mapping.chip_enum) {
-        default: return 902;
-        case RAVEN_A0:          return Mapping.xnack_supported ? 903 : 902;
-      }
-    }
-}
-
-std::string getFeatureString(const aclTargetInfo& target, amd::option::Options *OptionsObj)
-{
-  std::string FeatureStr;
-  if (isHSAILTarget(target)) {
-    uint64_t y = aclGetChipOptions(target);
-    FeatureStr += ((y & F_FP32_DENORMS) && !OptionsObj->oVariables->DenormsAreZero) ? '+' : '-';
-    FeatureStr += "fp32-denormals";
-
-    for (uint64_t x = 0; y != 0; y >>= 1, ++x) {
-      if ((1 << x) == F_FP32_DENORMS) {
-        continue;
-      }
-      if (!FeatureStr.empty()) {
-        FeatureStr += ',';
-      }
-      FeatureStr += ((y & 0x1) ? '+' : '-');
-      FeatureStr += HSAILCodeGenFlagTable[x];
-    }
-  }
-  return FeatureStr;
-}
-
-void
-appendLogToCL(aclCompiler *cl, const std::string &logStr)
-{
-  if (logStr.empty()) {
-    return;
-  }
-  std::string log = logStr;
-  if ('\n' != log[log.size()-1]) {
-    log.append("\n");
-  }
-  unsigned size = cl->logSize + log.size();
-  if (!size) {
-    return;
-  }
-  char *tmpBuildLog = reinterpret_cast<char*>(aclutAlloc(cl)(size + 2));
-  memset(tmpBuildLog, 0, size + 2);
-  if (cl->logSize) {
-    std::copy(cl->buildLog, cl->buildLog + cl->logSize, tmpBuildLog);
-    std::copy(log.begin(), log.end(), tmpBuildLog + cl->logSize);
-  } else {
-    std::copy(log.begin(), log.end(), tmpBuildLog);
-  }
-  cl->logSize += (unsigned int)log.size();
-  if (cl->buildLog) {
-    aclutFree(cl)(cl->buildLog);
-  }
-  cl->buildLog = tmpBuildLog;
-}
-
-static void
-setElfTarget(bifbase *elfBin, const aclTargetInfo *tgtInfo)
-{
-  uint16_t elf_target = 0;
-  switch (tgtInfo->arch_id) {
-    default:
-      assert(!"creating an elf for an invalid architecture!");
-    case aclX86:
-      elfBin->setTarget(EM_386, aclPlatformCompLib);
-      break;
-    case aclX64:
-      elfBin->setTarget(EM_X86_64, aclPlatformCompLib);
-      break;
-    case aclHSAIL:
-      elfBin->setTarget(EM_HSAIL, aclPlatformCompLib);
-      break;
-    case aclHSAIL64:
-      elfBin->setTarget(EM_HSAIL_64, aclPlatformCompLib);
-      break;
-    case aclAMDIL:
-      elfBin->setTarget(EM_AMDIL, aclPlatformCompLib);
-      break;
-    case aclAMDIL64:
-      elfBin->setTarget(EM_AMDIL_64, aclPlatformCompLib);
-      break;
-  }
-}
-// FIXME: this needs to be moved into the BIF classes.
-static void
-convertBIF30MachineTo2X(bifbase *elfBin, const aclTargetInfo *tgtInfo)
-{
-  uint16_t machine = 0;
-  uint32_t flags = 0;
-  aclPlatform pform = aclPlatformLast;
-  if (elfBin == NULL) return;
-  elfBin->getTarget(machine, pform);
-  assert(pform == aclPlatformCompLib
-      && "Platform is specified incorrectly!");
-  if (isCpuTarget(*tgtInfo)) {
-    assert(!"Not implemented/supported family detected!");
-    pform = aclPlatformCPU;
-  } else if (isAMDILTarget(*tgtInfo)) {
-    const char* chip = aclGetChip(*tgtInfo);
-    for (unsigned x = 0, y = sizeof(calTargetMapping)/sizeof(calTargetMapping[0]);
-        x < y; ++x) {
-      if (!strcmp(chip, calTargetMapping[x])) {
-        machine = x;
-        break;
-      }
-    }
-    pform = aclPlatformCAL;
-  } else {
-    assert(!"Not implemented/supported family detected!");
-  }
-  elfBin->setTarget(machine, pform);
-}
-// FIXME: This needs to be moved into the elf classes
-static void
-convertBIF2XMachineTo31(bifbase *elfBin)
-{
-  uint16_t machine = 0;
-  aclPlatform pform = aclPlatformLast;
-  if (elfBin == NULL) return;
-  elfBin->getTarget(machine, pform);
-  assert(pform != aclPlatformCompLib
-      && "Platform is specified incorrectly!");
-  if (pform == aclPlatformCPU) {
-      uint16_t type;
-      elfBin->getType(type);
-    machine = (type == ELFCLASS32 ? EM_386 : EM_X86_64);
-  } else if (pform == aclPlatformCAL) {
-    machine = EM_AMDIL;
-  } else {
-    assert(!"Unknown platform found!");
-  }
-  pform = aclPlatformCompLib;
-  elfBin->setTarget(machine, pform);
-}
-
-static void
-convertBIF2XMachineTo30(bifbase *elfBin)
-{
-  uint16_t machine = 0;
-  aclPlatform pform = aclPlatformLast;
-  if (elfBin == NULL) return;
-  elfBin->getTarget(machine, pform);
-  assert(pform != aclPlatformCompLib
-      && "Platform is specified incorrectly!");
-  if (pform == aclPlatformCPU) {
-      uint16_t type;
-      elfBin->getType(type);
-    machine = (type == ELFCLASS32 ? EM_386 : EM_X86_64);
-  } else if (pform == aclPlatformCAL) {
-    machine = EM_AMDIL;
-  } else {
-    assert(!"Unknown platform found!");
-  }
-  pform = aclPlatformCompLib;
-  elfBin->setTarget(machine, pform);
-}
-
-static void
-setElfFlags(bifbase *elfBin, const aclTargetInfo *tgtInfo)
-{
-  uint32_t flags = 0;
-  elfBin->getFlags(flags);
-  flags &= 0xFFFF0000;
-  const FamilyMapping *family = familySet + tgtInfo->arch_id;
-  flags = tgtInfo->chip_id & 0xFFFF;
-  elfBin->setFlags(flags);
-}
-
-static aclBinary*
-cloneOclElfNoBIF(const aclBinary *src) {
-  if (src == NULL) return NULL;
-  if (src->struct_size == sizeof(aclBinary_0_8_1)) {
-    aclBinary *dst = constructBinary(src->struct_size,
-        aclutGetTargetInfo(const_cast<aclBinary*>(src)),
-        aclutGetBinOpts(const_cast<aclBinary*>(src)));
-    if (dst == NULL) {
-      return NULL;
-    }
-    aclBinary_0_8_1 *dptr = reinterpret_cast<aclBinary_0_8_1*>(dst);
-    const aclBinary_0_8_1 *sptr = reinterpret_cast<const aclBinary_0_8_1*>(src);
-    dptr->target.struct_size = sizeof(aclTargetInfo_0_8);
-    if (sptr->target.struct_size == sizeof(aclTargetInfo_0_8)) {
-      memcpy(&dptr->target, &sptr->target, sptr->target.struct_size);
-    } else {
-      assert(!"Unsupported target info detected!");
-    }
-
-    memcpy(&dptr->caps, &sptr->caps, sptr->caps.struct_size);
-    assert(sizeof(aclDevCaps_0_8) == dptr->caps.struct_size);
-    amd::option::Options *Opts = reinterpret_cast<amd::option::Options*>(
-            aclutAlloc(src)(sizeof(amd::option::Options)));
-    Opts = new (Opts) amd::option::Options;
-    amd::option::Options *sOpts = reinterpret_cast<amd::option::Options*>(
-        sptr->options);
-    if (sOpts) {
-      parseAllOptions(sOpts->origOptionStr, *Opts);
-    }
-    dptr->options = reinterpret_cast<aclOptions*>(Opts);
-    dptr->bin = NULL;
-    return dst;
-  } else if (src->struct_size == sizeof(aclBinary_0_8)) {
-    aclBinary *dst = constructBinary(src->struct_size,
-        &src->target,
-        &src->binOpts);
-    if (dst == NULL) {
-      return NULL;
-    }
-    aclBinary_0_8 *dptr = reinterpret_cast<aclBinary_0_8*>(dst);
-    const aclBinary_0_8 *sptr = reinterpret_cast<const aclBinary_0_8*>(src);
-    dptr->target.struct_size = sizeof(aclTargetInfo_0_8);
-    if (sptr->target.struct_size == sizeof(aclTargetInfo_0_8)) {
-      memcpy(&dptr->target, &sptr->target, sptr->target.struct_size);
-    } else {
-      assert(!"Unsupported target info detected!");
-    }
-
-    memcpy(&dptr->caps, &sptr->caps, sptr->caps.struct_size);
-    assert(sizeof(aclDevCaps_0_8) == dptr->caps.struct_size
-        && "The caps struct is not version 0.7!");
-    amd::option::Options *Opts = reinterpret_cast<amd::option::Options*>(
-            aclutAlloc(src)(sizeof(amd::option::Options)));
-    Opts = new (Opts) amd::option::Options;
-    amd::option::Options *sOpts = reinterpret_cast<amd::option::Options*>(
-        sptr->options);
-    if (sOpts) {
-      parseAllOptions(sOpts->origOptionStr, *Opts);
-    }
-    dptr->options = reinterpret_cast<aclOptions*>(Opts);
-    dptr->bin = NULL;
-    return dst;
-  } else {
-    assert(!"Elf version not supported!");
-  }
-  return NULL;
-}
-
-// Create a copy of an ELF and duplicate all sections/symbols
-// All sections are copied verbatim.
-aclBinary*
-createELFCopy(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    bifbase* dstBin = NULL;
-    switch (srcBin->getVersion()) {
-      default:
-        assert(!"New/unknown version detected!");
-        dstBin = reinterpret_cast<bifbase*>(aclutAlloc(src)(sizeof(bifbase)));
-        dstBin = new (dstBin) bifbase(srcBin->getBase());
-        break;
-      case aclBIFVersion20:
-        dstBin = reinterpret_cast<bifbase*>(aclutAlloc(src)(sizeof(bif20)));
-        dstBin = new (dstBin) bif20(srcBin->get20()); break;
-      case aclBIFVersion21:
-        dstBin = reinterpret_cast<bifbase*>(aclutAlloc(src)(sizeof(bif21)));
-        dstBin = new (dstBin) bif21(srcBin->get21()); break;
-      case aclBIFVersion30:
-        dstBin = reinterpret_cast<bifbase*>(aclutAlloc(src)(sizeof(bif30)));
-        dstBin = new (dstBin) bif30(srcBin->get30()); break;
-      case aclBIFVersion31:
-        dstBin = reinterpret_cast<bifbase*>(aclutAlloc(src)(sizeof(bif31)));
-        dstBin = new (dstBin) bif31(srcBin->get31()); break;
-    }
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF2.1 elf from a BIF 2.0 elf.
-// All sections are copied and then if
-// CAL/DLL or JITBINARY sections are found,
-// the type is set to EXEC.
-aclBinary*
-convertBIF20ToBIF21(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get20() != NULL && "Passed in an invalid binary!");
-    bif21 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif21*>(aclutAlloc(src)(sizeof(bif21)));
-    dstBin = new (dstBin) bif21(srcBin->get20());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF3.0 elf from a BIF 2.0 elf.
-aclBinary*
-convertBIF20ToBIF30(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get20() != NULL && "Passed in an invalid binary!");
-    bif30 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif30*>(aclutAlloc(src)(sizeof(bif30)));
-    dstBin = new (dstBin) bif30(srcBin->get20());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-    convertBIF2XMachineTo30(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF3.1 elf from a BIF 2.0 elf.
-aclBinary*
-convertBIF20ToBIF31(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get20() != NULL && "Passed in an invalid binary!");
-    bif31 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif31*>(aclutAlloc(src)(sizeof(bif31)));
-    dstBin = new (dstBin) bif31(srcBin->get20());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-    convertBIF2XMachineTo31(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF2.0 elf from a BIF 2.1 elf.
-// All sections except for the COMMENT section is copied
-// verbatim and the section is set to NONE.
-aclBinary*
-convertBIF21ToBIF20(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get21() != NULL && "Passed in an invalid binary!");
-    bif20 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif20*>(aclutAlloc(src)(sizeof(bif20)));
-    dstBin = new (dstBin) bif20(srcBin->get21());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF3.0 elf from a BIF 2.1 elf.
-// See BIF spec for 2.1 to 3.0 conversion
-// and also include the comment section.
-aclBinary*
-convertBIF21ToBIF30(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get21() != NULL && "Passed in an invalid binary!");
-    bif30 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif30*>(aclutAlloc(src)(sizeof(bif30)));
-    dstBin = new (dstBin) bif30(srcBin->get21());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-    convertBIF2XMachineTo30(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF3.1 elf from a BIF 2.1 elf.
-// See BIF spec for 3.1 to 2.1 conversion.
-aclBinary*
-convertBIF21ToBIF31(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get21() != NULL && "Passed in an invalid binary!");
-    bif31 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif31*>(aclutAlloc(src)(sizeof(bif31)));
-    dstBin = new (dstBin) bif31(srcBin->get21());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-    convertBIF2XMachineTo31(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF2.0 elf from a BIF 3.0 elf.
-// See BIF spec for 3.0 to 2.0 conversion.
-aclBinary*
-convertBIF30ToBIF20(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get30() != NULL && "Passed in an invalid binary!");
-    bif20 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif20*>(aclutAlloc(src)(sizeof(bif20)));
-    dstBin = new (dstBin) bif20(srcBin->get30());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF2.1 elf from a BIF 3.0 elf
-// See BIF spec for 3.0 to 2.1 conversion
-// but also include the COMMENT section.
-aclBinary*
-convertBIF30ToBIF21(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get30() != NULL && "Passed in an invalid binary!");
-    bif21 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif21*>(aclutAlloc(src)(sizeof(bif21)));
-    dstBin = new (dstBin) bif21(srcBin->get30());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF3.1 elf from a BIF 3.0 elf
-// See BIF spec for 3.0 to 3.1 conversion.
-aclBinary*
-convertBIF30ToBIF31(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get30() != NULL && "Passed in an invalid binary!");
-    bif31 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif31*>(aclutAlloc(src)(sizeof(bif31)));
-    dstBin = new (dstBin) bif31(srcBin->get30());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF2.0 elf from a BIF 3.1 elf.
-// See BIF spec for 3.1 to 2.0 conversion.
-aclBinary*
-convertBIF31ToBIF20(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get31() != NULL && "Passed in an invalid binary!");
-    bif20 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif20*>(aclutAlloc(src)(sizeof(bif20)));
-    dstBin = new (dstBin) bif20(srcBin->get31());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF2.1 elf from a BIF 3.1 elf
-// See BIF spec for 3.1 to 2.1 conversion.
-aclBinary*
-convertBIF31ToBIF21(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get31() != NULL && "Passed in an invalid binary!");
-    bif21 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif21*>(aclutAlloc(src)(sizeof(bif21)));
-    dstBin = new (dstBin) bif21(srcBin->get31());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-// Create a BIF3.1 elf from a BIF 3.0 elf
-// See BIF spec for 3.0 to 3.1 conversion.
-aclBinary*
-convertBIF31ToBIF30(aclBinary *src) {
-  aclBinary *dst = cloneOclElfNoBIF(src);
-  if (dst != NULL) {
-    bifbase *srcBin = reinterpret_cast<bifbase*>(aclutGetBIF(src));
-    assert(srcBin->get31() != NULL && "Passed in an invalid binary!");
-    bif30 *dstBin = NULL;
-    dstBin = reinterpret_cast<bif30*>(aclutAlloc(src)(sizeof(bif30)));
-    dstBin = new (dstBin) bif30(srcBin->get31());
-    if (dstBin->hasError()) {
-      aclBinaryFini(dst);
-      return NULL;
-    }
-    dst->bin = reinterpret_cast<aclBIF*>(dstBin);
-  }
-  return dst;
-}
-
-void dump(aclBinary *bin) {
-  bifbase *elfBin = reinterpret_cast<bifbase*>(bin->bin);
-  elfBin->dump();
-}
-
-const std::string &getLegacyLibName() {
-  return legacyLibName;
-}
diff --git a/compiler/lib/utils/v0_8/target_mappings.h b/compiler/lib/utils/v0_8/target_mappings.h
deleted file mode 100644
index 1126dcd..0000000
--- a/compiler/lib/utils/v0_8/target_mappings.h
+++ /dev/null
@@ -1,306 +0,0 @@
-//
-// Copyright (c) 2011 Advanced Micro Devices, Inc. All rights reserved.
-//
-#ifndef _CL_UTILS_TARGET_MAPPINGS_0_8_H_
-#define _CL_UTILS_TARGET_MAPPINGS_0_8_H_
-#include "top.hpp"
-#include "library.hpp"
-#include "aclTypes.h"
-#ifndef FAMILY_UNKNOWN
-#define FAMILY_UNKNOWN 0
-#endif
-
-#ifndef FAMILY_X86
-#define FAMILY_X86 1
-#endif
-
-#ifndef FAMILY_X64
-#define FAMILY_X64 2
-#endif
-
-#define ARRAY_SIZEOF(A) (sizeof(A)/sizeof(A[0]))
-
-typedef struct _target_mappings_rec {
-  const char* family_name;
-  const char* chip_name;
-  const char* codegen_name;
-  amd::LibrarySelector lib;
-  unsigned chip_enum;
-  uint64_t chip_options;
-  bool supported; // a false value means this device is not supported.
-  bool default_chip; // Chip to select if multiple chips with the same name exist.
-  unsigned family_enum; // Only used for GPU devices currently, for CPU we should put features.
-  bool xnack_supported; // XNACK support as per http://confluence.amd.com/pages/viewpage.action?spaceKey=ASLC&title=AMDGPU+Target+Names 
-} TargetMapping;
-
-const TargetMapping UnknownTarget = { "UnknownFamily", "UnknownChip", "UnknownCodeGen",
-  amd::LibraryUndefined, 0, 0, false, false, FAMILY_UNKNOWN, false};
-const TargetMapping InvalidTarget = { NULL, NULL, NULL,
-  amd::LibraryUndefined, 0, 0, false, false, FAMILY_UNKNOWN, false};
-
-typedef struct _family_map_rec {
-  const TargetMapping*  target;
-  const char* architecture;
-  const char* triple;
-  unsigned children_size;
-} FamilyMapping;
-const FamilyMapping UnknownFamily = { NULL, "UnknownFamily", "unknown", 0 };
-const FamilyMapping InvalidFamily = { NULL, NULL, NULL, 0 };
-typedef enum  {
-  F_CPU_CMOV      =  1,
-  F_CPU_POPCNT    =  2,
-  F_CPU_MMX       =  3,
-  F_CPU_SSE1      =  4,
-  F_CPU_SSE2      =  5,
-  F_CPU_SSE3      =  6,
-  F_CPU_SSSE3     =  7,
-  F_CPU_SSE41     =  8,
-  F_CPU_SSE42     =  9,
-  F_CPU_SSE4A     = 10,
-  F_CPU_3DNow     = 11,
-  F_CPU_3DNowA    = 12,
-  F_CPU_64Bit     = 13,
-  F_CPU_SBTMem    = 14,
-  F_CPU_FUAMem    = 15,
-  F_CPU_AVX       = 16,
-  F_CPU_CLMUL     = 17,
-  F_CPU_VUAMem    = 18,
-  F_CPU_AES       = 19,
-  F_CPU_CXCHG16B  = 20,
-  F_CPU_AVX2      = 21,
-  F_CPU_FMA3      = 22,
-  F_CPU_FMA4      = 23,
-  F_CPU_MOVBE     = 24,
-  F_CPU_RDRAND    = 25,
-  F_CPU_F16C      = 26,
-  F_CPU_64BitMode = 27,
-  F_CPU_LZCNT     = 28,
-  F_CPU_BMI       = 29,
-  F_CPU_BMI2      = 30, // LLVM 3.1 only
-  F_CPU_LeaForSP  = 31, // LLVM 3.1 only
-  F_CPU_FSGSBASE  = 32, // LLVM 3.1 only
-  F_CPU_XOP       = 33, // LLVM 3.1 only
-  F_CPU_ATOM      = 34, // LLVM 3.1 only
-  F_CPU_LAST      = 35
-} CPUCodeGenFlags;
-
-static const char* CPUCodeGenFlagTable[] =
-{
-  "cmov",
-  "popcnt",
-  "mmx",
-  "sse",
-  "sse2",
-  "sse3",
-  "ssse3",
-  "sse41",
-  "sse42",
-  "sse4a",
-  "3dnow",
-  "3dnowa",
-  "64bit",
-  "slow-bt-mem",
-  "fast-unaligned-mem",
-  "avx",
-  "clmul",
-  "vector-unaligned-mem",
-  "aes",
-  "cmpxchg16b",
-  "avx2",
-  "fma3",
-  "fma4",
-  "movbe",
-  "rdrand",
-  "f16c",
-  "fsgsbase",
-  "lzcnt",
-  "bmi",
-  "bmi2",
-  "lea-sp",
-  "64bit-mode",
-  "xop",
-  "atom"
-};
-
-typedef enum {
-  // Bits for each feature.
-  F_FP64              = 0x0001,
-  F_BYTE_ADDRESSABLE  = 0x0002,
-  F_BARRIER_DETECT    = 0x0004,
-  F_IMAGES            = 0x0008,
-  F_MULTI_UAV         = 0x0010,
-  F_MACRO_DB          = 0x0020,
-  F_NO_ALIAS          = 0x0040,
-  F_NO_INLINE         = 0x0080,
-  F_64BIT_PTR         = 0x0100,
-  F_32ON64BIT_PTR     = 0x0200,
-  F_DEBUG             = 0x0400,
-  F_MWGS_256          = 0x0800,
-  F_MWGS_128          = 0x1000,
-  F_MWGS_64           = 0x2000,
-  F_MWGS_32           = 0x4000,
-  F_MWGS_16           = 0x8000,
-  F_MD_30             = 0x10000,
-  F_STACK_UAV         = 0x20000,
-  F_MACRO_CALL        = 0x40000,
-  // Bitmasks for each device type.
-  F_RV7XX_BASE        = F_MACRO_DB|F_BARRIER_DETECT|F_MD_30,
-  F_RV710             = F_RV7XX_BASE|F_MWGS_32,
-  F_RV730             = F_RV7XX_BASE|F_MWGS_16,
-  F_RV770             = F_RV7XX_BASE|F_MWGS_64|F_FP64,
-  F_EG_BASE           = F_BYTE_ADDRESSABLE|F_IMAGES|F_MACRO_DB|F_MD_30,
-  F_EG_EXT            = F_EG_BASE|F_FP64|F_MWGS_256,
-  F_CEDAR             = F_EG_BASE|F_MWGS_128,
-  F_REDWOOD           = F_EG_BASE|F_MWGS_256,
-  F_JUNIPER           = F_EG_BASE|F_MWGS_256,
-  F_NI_BASE           = F_EG_BASE|F_MWGS_256,
-  F_NI_EXT            = F_NI_BASE|F_FP64,
-  F_SI_BASE           = F_NI_EXT|F_STACK_UAV|F_MACRO_CALL,
-  F_SI_64BIT_PTR      = F_SI_BASE|F_64BIT_PTR
-} GPUCodeGenFlags;
-
-typedef enum {
-  // Bits for each feature.
-  F_FP32_DENORMS      = 0x0001,
-  // Bitmasks for each device type.
-  F_CI_BASE           = 0,
-  F_VI_BASE           = F_CI_BASE | F_FP32_DENORMS,
-  F_AI_BASE           = F_VI_BASE
-} HSAILCodeGenFlags;
-
-static const char* GPUCodeGenFlagTable[] = {
-  "fp64",
-  "byte_addressable_store",
-  "barrier_detect",
-  "images",
-  "multi_uav",
-  "macrodb",
-  "noalias",
-  "no-inline",
-  "64bitptr",
-  "small-global-objects",
-  "debug",
-  "mwgs-3-256-1-1",
-  "mwgs-3-128-1-1",
-  "mwgs-3-64-1-1",
-  "mwgs-3-32-1-1",
-  "mwgs-3-16-1-1",
-  "metadata30",
-  "stack-uav",
-  "macro-call"
-};
-
-static const char* HSAILCodeGenFlagTable[] = {
-  "fp32-denormals"
-};
-
-static const char* calTargetMapping[] = {
-      "RV600", "RV610", "RV630", "RV670",
-      "RV770", "RV770", "RV710", "RV730",
-      "Cypress", "Juniper", "Redwood", "Cedar",
-      "WinterPark", "BeaverCreek", "Loveland",
-      "Cayman", "Kauai", "Barts", "Turks", "Caicos",
-      "Tahiti", "Pitcairn", "Capeverde",
-      "Devastator", "Scrapper",
-      "Oland", "Bonaire",
-      "Spectre", "Spooky", "Kalindi",
-      "Hainan", "Hawaii",
-      "Iceland", "Tonga", "Mullins", "Fiji",
-      "Carrizo", "Ellesmere", "Baffin",
-      IF(IS_BRAHMA,"","gfx900"),
-      "Stoney",
-      "gfx804",
-      IF(IS_BRAHMA,"","gfx901"),
-      IF(IS_BRAHMA,"","gfx902"),
-      IF(IS_BRAHMA,"","gfx903"),
-      IF(IS_BRAHMA,"","gfx904"),
-      IF(IS_BRAHMA,"","gfx905"),
-      IF(IS_BRAHMA,"","gfx906"),
-      IF(IS_BRAHMA,"","gfx907"),
-};
-
-#include "utils/v0_8/target_mappings_amdil.h"
-#include "utils/v0_8/target_mappings_hsail.h"
-#include "utils/v0_8/target_mappings_x86.h"
-#include "utils/v0_8/target_mappings_x64.h"
-#include "utils/v0_8/target_mappings_amdil64.h"
-#include "utils/v0_8/target_mappings_hsail64.h"
-// FIXME: Add static asserts to make sure that all of the arrays for TargetMapping match the enum table.
-
-#define DATA_LAYOUT_64BIT "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16" \
-                "-i32:32:32-i64:64:64-f32:32:32-f64:64:64-f80:32:32" \
-                "-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64" \
-                "-v96:128:128-v128:128:128-v192:256:256-v256:256:256" \
-                "-v512:512:512-v1024:1024:1024-v2048:2048:2048-a0:0:64" \
-                "-n32"
-
-#define DATA_LAYOUT_32BIT "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16" \
-                "-i32:32:32-i64:64:64-f32:32:32-f64:64:64-f80:32:32" \
-                "-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64" \
-                "-v96:128:128-v128:128:128-v192:256:256-v256:256:256" \
-                "-v512:512:512-v1024:1024:1024-v2048:2048:2048-a0:0:64" \
-                "-n32"
-
-inline const char* getArchitecture(aclDevType arch_id)
-{
-  switch (arch_id) {
-    case aclX86:
-      return "x86";
-    case aclAMDIL:
-      return "amdil";
-    case aclHSAIL:
-      return "hsail";
-    case aclX64:
-      return "x86-64";
-    case aclHSAIL64:
-      return "hsail64";
-    case aclAMDIL64:
-      return "amdil64";
-    default:
-      return NULL;
-  }
-}
-
-inline const char* getTriple(aclDevType arch_id)
-{
-  switch (arch_id) {
-    case aclX86:
-#ifdef _WIN32
-      return "i686-pc-mingw32-amdopencl";
-#else
-      return "i686-pc-linux-amdopencl";
-#endif
-    case aclAMDIL:
-      return "amdil-pc-unknown-amdopencl";
-    case aclHSAIL:
-      return "hsail-pc-unknown-amdopencl";
-    case aclX64:
-#ifdef _WIN32
-      return "x86_64-pc-mingw32-amdopencl";
-#else
-      return "x86_64-pc-linux-amdopencl";
-#endif
-    case aclHSAIL64:
-      return "hsail64-pc-unknown-amdopencl";
-    case aclAMDIL64:
-      return "amdil64-pc-unknown-amdopencl";
-    default:
-      return NULL;
-  }
-}
-
-// The contents of this array has to match the sequence defined in
-// aclDevType_0_8
-static const FamilyMapping familySet[] =
-{
-  UnknownFamily,
-  { (const TargetMapping*)&X86TargetMapping_0_8, getArchitecture(aclX86), getTriple(aclX86), ARRAY_SIZEOF(X86TargetMapping_0_8) },
-  { (const TargetMapping*)&AMDILTargetMapping_0_8, getArchitecture(aclAMDIL), getTriple(aclAMDIL), ARRAY_SIZEOF(AMDILTargetMapping_0_8) },
-  { (const TargetMapping*)&HSAILTargetMapping_0_8, getArchitecture(aclHSAIL), getTriple(aclHSAIL), ARRAY_SIZEOF(HSAILTargetMapping_0_8) },
-  { (const TargetMapping*)&X64TargetMapping_0_8, getArchitecture(aclX64), getTriple(aclX64), ARRAY_SIZEOF(X64TargetMapping_0_8) },
-  { (const TargetMapping*)&HSAIL64TargetMapping_0_8, getArchitecture(aclHSAIL64), getTriple(aclHSAIL64), ARRAY_SIZEOF(HSAIL64TargetMapping_0_8) },
-  { (const TargetMapping*)&AMDIL64TargetMapping_0_8, getArchitecture(aclAMDIL64), getTriple(aclAMDIL64), ARRAY_SIZEOF(AMDIL64TargetMapping_0_8) },
-  InvalidFamily
-};
-
-#endif // _CL_UTILS_TARGET_MAPPINGS_0_8_H_
diff --git a/compiler/lib/utils/v0_8/target_mappings_amdil.h b/compiler/lib/utils/v0_8/target_mappings_amdil.h
deleted file mode 100644
index ebb1b63..0000000
--- a/compiler/lib/utils/v0_8/target_mappings_amdil.h
+++ /dev/null
@@ -1,113 +0,0 @@
-//
-// Copyright (c) 2012 Advanced Micro Devices, Inc. All rights reserved.
-//
-#ifndef _CL_UTILS_TARGET_MAPPINGS_AMDIL_0_8_H_
-#define _CL_UTILS_TARGET_MAPPINGS_AMDIL_0_8_H_
-
-#include "evergreen_id.h"
-#include "r700id.h"
-#include "tn_id.h"
-#include "sumo_id.h"
-#include "northernisland_id.h"
-#include "si_id.h"
-#include "kv_id.h"
-#include "ci_id.h"
-#include "vi_id.h"
-#include "cz_id.h"
-#include "ai_id.h"
-#include "atiid.h"
-
-static const TargetMapping AMDILTargetMapping_0_8[] = {
-  UnknownTarget,
-  { "R7XX", "RV770", "rv770", amd::GPU_Library_7xx, WEKIVA_A11,    F_RV770, false, false, FAMILY_RV7XX },
-  { "R7XX", "RV770", "rv770", amd::GPU_Library_7xx, WEKIVA_A12,    F_RV770, false, true , FAMILY_RV7XX },
-  { "R7XX", "RV790", "rv770", amd::GPU_Library_7xx, WEKIVA_A21,    F_RV770, false, true , FAMILY_RV7XX },
-  { "R7XX", "RV730", "rv730", amd::GPU_Library_7xx, MARIO_A11,     F_RV730, false, false, FAMILY_RV7XX },
-  { "R7XX", "RV730", "rv730", amd::GPU_Library_7xx, MARIO_A12,     F_RV730, false, false, FAMILY_RV7XX },
-  { "R7XX", "RV730", "rv730", amd::GPU_Library_7xx, MARIO_A13,     F_RV730, false, true , FAMILY_RV7XX },
-  { "R7XX", "RV710", "rv710", amd::GPU_Library_7xx, LUIGI_A11,     F_RV710, false, false, FAMILY_RV7XX },
-  { "R7XX", "RV710", "rv710", amd::GPU_Library_7xx, LUIGI_A12,     F_RV710, false, true , FAMILY_RV7XX },
-  { "R7XX", "RV710", "rv710", amd::GPU_Library_7xx, LUIGI_APU_A11, F_RV710, false, false, FAMILY_RV7XX },
-  { "R7XX", "RV740", "rv770", amd::GPU_Library_7xx, WALDEN_A11,    F_RV770, false, false, FAMILY_RV7XX },
-  { "R7XX", "RV740", "rv770", amd::GPU_Library_7xx, WALDEN_A12,    F_RV770, false, true , FAMILY_RV7XX },
-  { "Evergreen", "Cypress", "cypress", amd::GPU_Library_Evergreen, CYPRESS_A11, F_EG_EXT, false , false, FAMILY_EVERGREEN },
-  { "Evergreen", "Cypress", "cypress", amd::GPU_Library_Evergreen, CYPRESS_A12, F_EG_EXT, false , true , FAMILY_EVERGREEN },
-  { "Evergreen", "Juniper", "juniper", amd::GPU_Library_Evergreen, JUNIPER_A11, F_JUNIPER, false , false, FAMILY_EVERGREEN },
-  { "Evergreen", "Juniper", "juniper", amd::GPU_Library_Evergreen, JUNIPER_A12, F_JUNIPER, false , true , FAMILY_EVERGREEN },
-  { "Evergreen", "Redwood", "redwood", amd::GPU_Library_Evergreen, REDWOOD_A11, F_REDWOOD, false , false, FAMILY_EVERGREEN },
-  { "Evergreen", "Redwood", "redwood", amd::GPU_Library_Evergreen, REDWOOD_A12, F_REDWOOD, false , true , FAMILY_EVERGREEN },
-  { "Evergreen", "Cedar",   "cedar",   amd::GPU_Library_Evergreen, CEDAR_A11,   F_CEDAR, false , false, FAMILY_EVERGREEN },
-  { "Evergreen", "Cedar",   "cedar",   amd::GPU_Library_Evergreen, CEDAR_A12,   F_CEDAR, false , true , FAMILY_EVERGREEN },
-  { "NI", "Cayman", "cayman", amd::GPU_Library_Evergreen, NI_CAYMAN_P_A11,       F_NI_EXT,  false , true , FAMILY_NI },
-  { "NI", "Barts",  "barts",  amd::GPU_Library_Evergreen, NI_BARTS_PM_A11,       F_NI_BASE, false , true , FAMILY_NI },
-  { "NI", "Turks",  "turks",  amd::GPU_Library_Evergreen, NI_TURKS_M_A11,        F_NI_BASE, false , true , FAMILY_NI },
-  { "NI", "Lombok", "turks",  amd::GPU_Library_Evergreen, NI_TURKS_LOMBOK_M_A11, F_NI_BASE, false , true , FAMILY_NI },
-  { "NI", "Caicos", "caicos", amd::GPU_Library_Evergreen, NI_CAICOS_V_A11,       F_NI_BASE, false , true , FAMILY_NI },
-  { "NI", "Kauai",  "kauai",  amd::GPU_Library_Evergreen, KAUAI_A11,             F_NI_BASE, false, false, FAMILY_NI },
-  { "Sumo", "BeaverCreek", "redwood", amd::GPU_Library_Evergreen, SUPERSUMO_A0, F_REDWOOD, false , false, FAMILY_SUMO },
-  { "Sumo", "BeaverCreek", "redwood", amd::GPU_Library_Evergreen, SUPERSUMO_B0, F_REDWOOD, false , true , FAMILY_SUMO },
-  { "Sumo", "WinterPark",  "redwood", amd::GPU_Library_Evergreen,      SUMO_A0, F_REDWOOD, false , false, FAMILY_SUMO },
-  { "Sumo", "WinterPark",  "redwood", amd::GPU_Library_Evergreen,      SUMO_B0, F_REDWOOD, false , true , FAMILY_SUMO },
-  { "Sumo", "Loveland",    "cedar",   amd::GPU_Library_Evergreen,  WRESTLER_A0, F_REDWOOD, false , false, FAMILY_SUMO },
-  { "Sumo", "Loveland",    "cedar",   amd::GPU_Library_Evergreen,  WRESTLER_A1, F_REDWOOD, false , false, FAMILY_SUMO },
-  { "Sumo", "Loveland",    "cedar",   amd::GPU_Library_Evergreen,  WRESTLER_B0, F_REDWOOD, false , false, FAMILY_SUMO },
-  { "Sumo", "Loveland",    "cedar",   amd::GPU_Library_Evergreen,  WRESTLER_C0, F_REDWOOD, false , true , FAMILY_SUMO },
-  { "Sumo", "Bheem",       "cedar",   amd::GPU_Library_Evergreen,     BHEEM_A0, F_REDWOOD, false , true , FAMILY_SUMO },
-  { "SI", "Tahiti",    "tahiti",   amd::GPU_Library_SI, SI_TAHITI_P_A11,    F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",   amd::GPU_Library_SI, SI_TAHITI_P_A0,     F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",   amd::GPU_Library_SI, SI_TAHITI_P_A21,    F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",   amd::GPU_Library_SI, SI_TAHITI_P_B0,     F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",   amd::GPU_Library_SI, SI_TAHITI_P_A22,    F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",   amd::GPU_Library_SI, SI_TAHITI_P_B1,     F_SI_BASE, true , true, FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU_Library_SI, SI_PITCAIRN_PM_A11, F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU_Library_SI, SI_PITCAIRN_PM_A0,  F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU_Library_SI, SI_PITCAIRN_PM_A12, F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU_Library_SI, SI_PITCAIRN_PM_A1,  F_SI_BASE, true , true, FAMILY_SI },
-  { "SI", "Capeverde", "capeverde",   amd::GPU_Library_SI, SI_CAPEVERDE_M_A11, F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Capeverde", "capeverde",   amd::GPU_Library_SI, SI_CAPEVERDE_M_A0,  F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Capeverde", "capeverde",   amd::GPU_Library_SI, SI_CAPEVERDE_M_A12, F_SI_BASE, true ,false, FAMILY_SI },
-  { "SI", "Capeverde", "capeverde",   amd::GPU_Library_SI, SI_CAPEVERDE_M_A1,  F_SI_BASE, true , true, FAMILY_SI },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_M_A0,       F_NI_EXT, false, false, FAMILY_TN },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_M_A1,       F_NI_EXT, false, true,  FAMILY_TN },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_LITE_MV_A0, F_NI_EXT, false, false, FAMILY_TN },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_LITE_MV_A1, F_NI_EXT, false, false, FAMILY_TN },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_V_A0,       F_NI_EXT, false, false, FAMILY_TN },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_V_A1,       F_NI_EXT, false, false, FAMILY_TN },
-  { "TN", "Scrapper",   "trinity", amd::GPU_Library_Evergreen, TN_SCRAPPER_V_A0,         F_NI_EXT, false, false, FAMILY_TN },
-  { "TN", "Scrapper",   "trinity", amd::GPU_Library_Evergreen, TN_SCRAPPER_V_A1,         F_NI_EXT, false, true,  FAMILY_TN },
-  { "TN", "Scrapper",   "trinity", amd::GPU_Library_Evergreen, TN_DVST_DUO_V_A0,         F_NI_EXT, false, false, FAMILY_TN },
-  { "KV", "Spectre",    "spectre", amd::GPU_Library_CI,        KV_SPECTRE_A0,           F_SI_BASE, false, true, FAMILY_KV },
-  { "KV", "Spooky",     "spooky",  amd::GPU_Library_CI,        KV_SPOOKY_A0,            F_SI_BASE, false, true, FAMILY_KV },
-  { "KV", "Kalindi",    "kalindi", amd::GPU_Library_CI,        KB_KALINDI_A0,           F_SI_BASE, false, true, FAMILY_KV },
-  { "CI", "Hawaii",     "hawaii",  amd::GPU_Library_CI,        CI_HAWAII_P_A0,          F_SI_BASE, false, true, FAMILY_CI },
-  { "KV", "Mullins",    "mullins", amd::GPU_Library_CI,        ML_GODAVARI_A0,          F_SI_BASE, false, true, FAMILY_KV },
-  { "SI", "Oland",      "oland",   amd::GPU_Library_SI,        SI_OLAND_M_A0,           F_SI_BASE, true, true, FAMILY_SI },
-  { "CI", "Bonaire",    "bonaire", amd::GPU_Library_CI,        CI_BONAIRE_M_A0,         F_SI_BASE, false, false, FAMILY_CI },
-  { "SI", "Hainan",     "hainan",  amd::GPU_Library_SI,        SI_HAINAN_V_A0,          F_SI_BASE, true, true, FAMILY_SI },
-#ifndef OPENCL_MAINLINE
-  { "CI", "Tiran",      "owls",    amd::GPU_Library_CI,        CI_TIRAN_P_A0,           F_SI_BASE, false, true, FAMILY_CI },
-  { "CI", "Maui",       "eagle",   amd::GPU_Library_CI,        CI_MAUI_P_A0,            F_SI_BASE, false, true, FAMILY_CI },
-#else
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  { "CZ", "Carrizo",    "carrizo", amd::GPU_Library_CI,        CARRIZO_A0,               F_SI_BASE, false, true,  FAMILY_CZ },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_W_A0,       F_NI_EXT,  false, false, FAMILY_TN },
-  { "TN", "Devastator", "trinity", amd::GPU_Library_Evergreen, TN_DEVASTATOR_W_A1,       F_NI_EXT,  false, false, FAMILY_TN },
-  { "TN", "Scrapper",   "trinity", amd::GPU_Library_Evergreen, TN_SCRAPPER_LV_A0,        F_NI_EXT,  false, false, FAMILY_TN },
-  { "TN", "Scrapper",   "trinity", amd::GPU_Library_Evergreen, TN_SCRAPPER_LV_A1,        F_NI_EXT,  false, false, FAMILY_TN },
-
-  { "VI", "Iceland",    "iceland", amd::GPU_Library_CI,        VI_ICELAND_M_A0,          F_SI_BASE, false, true, FAMILY_VI },
-  { "VI", "Tonga",      "tonga",   amd::GPU_Library_CI,        VI_TONGA_P_A0,            F_SI_BASE, false, true, FAMILY_VI },
-  { "CI", "Bonaire",    "bonaire", amd::GPU_Library_CI,        CI_BONAIRE_M_A1,          F_SI_BASE, false, true, FAMILY_CI },
-  { "VI", "Fiji",       "fiji",    amd::GPU_Library_CI,        VI_FIJI_P_A0,             F_SI_BASE, false, true, FAMILY_VI },
-  { "CZ", "Stoney",     "stoney",  amd::GPU_Library_CI,        STONEY_A0,                F_SI_BASE, false, true, FAMILY_CZ },
-  { "VI", "Baffin",     "baffin",  amd::GPU_Library_CI,        VI_BAFFIN_M_A0,           F_SI_BASE, false, false, FAMILY_VI },
-  { "VI", "Baffin",     "baffin",  amd::GPU_Library_CI,        VI_BAFFIN_M_A1,           F_SI_BASE, false, true, FAMILY_VI },
-  { "VI", "Ellesmere",  "ellesmere", amd::GPU_Library_CI,      VI_ELLESMERE_P_A0,        F_SI_BASE, false, false, FAMILY_VI },
-  { "VI", "Ellesmere",  "ellesmere", amd::GPU_Library_CI,      VI_ELLESMERE_P_A1,        F_SI_BASE, false, true, FAMILY_VI },
-  { "VI", "gfx804",     "gfx804",    amd::GPU_Library_CI,      VI_LEXA_V_A0,             F_SI_BASE, false, true, FAMILY_VI },
-  InvalidTarget
-};
-
-#endif // _CL_UTILS_TARGET_MAPPINGS_AMDIL_0_8_H_
diff --git a/compiler/lib/utils/v0_8/target_mappings_amdil64.h b/compiler/lib/utils/v0_8/target_mappings_amdil64.h
deleted file mode 100644
index 5a894f5..0000000
--- a/compiler/lib/utils/v0_8/target_mappings_amdil64.h
+++ /dev/null
@@ -1,59 +0,0 @@
-//
-// Copyright (c) 2012 Advanced Micro Devices, Inc. All rights reserved.
-//
-#ifndef _CL_UTILS_TARGET_MAPPINGS_AMDIL64_0_8_H_
-#define _CL_UTILS_TARGET_MAPPINGS_AMDIL64_0_8_H_
-
-#include "si_id.h"
-#include "kv_id.h"
-#include "ci_id.h"
-#include "vi_id.h"
-#include "cz_id.h"
-#include "atiid.h"
-
-static const TargetMapping AMDIL64TargetMapping_0_8[] = {
-  UnknownTarget,
-  { "SI", "Tahiti",    "tahiti",    amd::GPU64_Library_SI, SI_TAHITI_P_A11,    F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",    amd::GPU64_Library_SI, SI_TAHITI_P_A0,     F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",    amd::GPU64_Library_SI, SI_TAHITI_P_A21,    F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",    amd::GPU64_Library_SI, SI_TAHITI_P_B0,     F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",    amd::GPU64_Library_SI, SI_TAHITI_P_A22,    F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Tahiti",    "tahiti",    amd::GPU64_Library_SI, SI_TAHITI_P_B1,     F_SI_64BIT_PTR, true,  true,  FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU64_Library_SI, SI_PITCAIRN_PM_A11, F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU64_Library_SI, SI_PITCAIRN_PM_A0,  F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU64_Library_SI, SI_PITCAIRN_PM_A12, F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Pitcairn",  "pitcairn",  amd::GPU64_Library_SI, SI_PITCAIRN_PM_A1,  F_SI_64BIT_PTR, true,  true,  FAMILY_SI },
-  { "SI", "Capeverde", "capeverde", amd::GPU64_Library_SI, SI_CAPEVERDE_M_A11, F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Capeverde", "capeverde", amd::GPU64_Library_SI, SI_CAPEVERDE_M_A0,  F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Capeverde", "capeverde", amd::GPU64_Library_SI, SI_CAPEVERDE_M_A12, F_SI_64BIT_PTR, true,  false, FAMILY_SI },
-  { "SI", "Capeverde", "capeverde", amd::GPU64_Library_SI, SI_CAPEVERDE_M_A1,  F_SI_64BIT_PTR, true,  true,  FAMILY_SI },
-  { "KV", "Spectre",   "spectre",   amd::GPU64_Library_CI, KV_SPECTRE_A0,      F_SI_64BIT_PTR, false, true,  FAMILY_KV },
-  { "KV", "Spooky",    "spooky",    amd::GPU64_Library_CI, KV_SPOOKY_A0,       F_SI_64BIT_PTR, false, true,  FAMILY_KV },
-  { "KV", "Kalindi",   "kalindi",   amd::GPU64_Library_CI, KB_KALINDI_A0,      F_SI_64BIT_PTR, false, true,  FAMILY_KV },
-  { "CI", "Hawaii",    "hawaii",    amd::GPU64_Library_CI, CI_HAWAII_P_A0,     F_SI_64BIT_PTR, false, true,  FAMILY_CI },
-  { "KV", "Mullins",   "mullins",   amd::GPU64_Library_CI, ML_GODAVARI_A0,     F_SI_64BIT_PTR, false, true,  FAMILY_KV },
-  { "SI", "Oland",     "oland",     amd::GPU64_Library_SI, SI_OLAND_M_A0,      F_SI_64BIT_PTR, true,  true,  FAMILY_SI },
-  { "CI", "Bonaire",   "bonaire",   amd::GPU64_Library_CI, CI_BONAIRE_M_A0,    F_SI_64BIT_PTR, false, false, FAMILY_CI },
-  { "SI", "Hainan",    "hainan",    amd::GPU64_Library_SI, SI_HAINAN_V_A0,     F_SI_64BIT_PTR, true,  true,  FAMILY_SI },
-#ifndef OPENCL_MAINLINE
-  { "CI", "Tiran",     "owls",      amd::GPU64_Library_CI, CI_TIRAN_P_A0,      F_SI_64BIT_PTR, false, false, FAMILY_CI },
-  { "CI", "Maui",      "eagle",     amd::GPU64_Library_CI, CI_MAUI_P_A0,       F_SI_64BIT_PTR, false, true,  FAMILY_CI },
-#else
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  { "CZ", "Carrizo",   "carrizo",   amd::GPU64_Library_CI, CARRIZO_A0,         F_SI_64BIT_PTR, false, true,  FAMILY_CZ },
-  { "VI", "Iceland",    "iceland",  amd::GPU64_Library_CI, VI_ICELAND_M_A0,    F_SI_64BIT_PTR, false, true,  FAMILY_VI },
-  { "VI", "Tonga",      "tonga",    amd::GPU64_Library_CI, VI_TONGA_P_A0,      F_SI_64BIT_PTR, false, true,  FAMILY_VI },
-  { "CI", "Bonaire",   "bonaire",   amd::GPU64_Library_CI, CI_BONAIRE_M_A0,    F_SI_64BIT_PTR, false, true,  FAMILY_CI },
-  { "VI", "Fiji",      "fiji",      amd::GPU64_Library_CI, VI_FIJI_P_A0,       F_SI_64BIT_PTR, false, true,  FAMILY_VI },
-  { "CZ", "Stoney",    "stoney",    amd::GPU64_Library_CI, STONEY_A0,          F_SI_64BIT_PTR, false, true,  FAMILY_CZ },
-  { "VI", "Baffin",    "baffin",    amd::GPU64_Library_CI, VI_BAFFIN_M_A0,     F_SI_64BIT_PTR, false, false, FAMILY_VI },
-  { "VI", "Baffin",    "baffin",    amd::GPU64_Library_CI, VI_BAFFIN_M_A1,     F_SI_64BIT_PTR, false, true,  FAMILY_VI },
-  { "VI", "Ellesmere", "ellesmere", amd::GPU64_Library_CI, VI_ELLESMERE_P_A0,  F_SI_64BIT_PTR, false, false, FAMILY_VI },
-  { "VI", "Ellesmere", "ellesmere", amd::GPU64_Library_CI, VI_ELLESMERE_P_A1,  F_SI_64BIT_PTR, false, true,  FAMILY_VI },
-  { "VI", "gfx804",    "gfx804",    amd::GPU64_Library_CI, VI_LEXA_V_A0,       F_SI_64BIT_PTR, false, true,  FAMILY_VI },
-  InvalidTarget
-};
-
-#endif // _CL_UTILS_TARGET_MAPPINGS_AMDIL64_0_8_H_
diff --git a/compiler/lib/utils/v0_8/target_mappings_hsail.h b/compiler/lib/utils/v0_8/target_mappings_hsail.h
deleted file mode 100644
index e1c97f1..0000000
--- a/compiler/lib/utils/v0_8/target_mappings_hsail.h
+++ /dev/null
@@ -1,70 +0,0 @@
-//
-// Copyright (c) 2012 Advanced Micro Devices, Inc. All rights reserved.
-//
-#ifndef _CL_UTILS_TARGET_MAPPINGS_HSAIL_0_8_H_
-#define _CL_UTILS_TARGET_MAPPINGS_HSAIL_0_8_H_
-
-#include "si_id.h"
-#include "kv_id.h"
-#include "ci_id.h"
-#include "cz_id.h"
-#include "ai_id.h"
-#include "rv_id.h"
-#include "atiid.h"
-
-static const TargetMapping HSAILTargetMapping_0_8[] = {
-  UnknownTarget,
-  { "KV", "Spectre",   "GFX7", amd::GPU_Library_HSAIL, KV_SPECTRE_A0,   F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "KV", "Spooky",    "GFX7", amd::GPU_Library_HSAIL, KV_SPOOKY_A0,    F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "KV", "Kalindi",   "GFX7", amd::GPU_Library_HSAIL, KB_KALINDI_A0,   F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "KV", "Mullins",   "GFX7", amd::GPU_Library_HSAIL, ML_GODAVARI_A0,  F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "CI", "Bonaire",   "GFX7", amd::GPU_Library_HSAIL, CI_BONAIRE_M_A0, F_CI_BASE, true, false, FAMILY_CI, false },
-  { "CI", "Bonaire",   "GFX7", amd::GPU_Library_HSAIL, CI_BONAIRE_M_A1, F_CI_BASE, true, true,  FAMILY_CI, false },
-  { "CI", "Hawaii",    "GFX7", amd::GPU_Library_HSAIL, CI_HAWAII_P_A0,  F_CI_BASE, true, true,  FAMILY_CI, false },
-  { "VI", "Iceland",   "GFX8", amd::GPU_Library_HSAIL, VI_ICELAND_M_A0, F_VI_BASE, true, true,  FAMILY_VI, false },
-  { "VI", "Tonga",     "GFX8", amd::GPU_Library_HSAIL, VI_TONGA_P_A0,   F_VI_BASE, true, true,  FAMILY_VI, false },
-#ifndef OPENCL_MAINLINE
-  { "CI", "Tiran",     "GFX7", amd::GPU_Library_HSAIL, CI_TIRAN_P_A0,   F_VI_BASE, true, true,  FAMILY_CI, false },
-  { "CI", "Maui",      "GFX7", amd::GPU_Library_HSAIL, CI_MAUI_P_A0,    F_VI_BASE, true, true,  FAMILY_CI, false },
-#else
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  { "CZ", "Carrizo",   "GFX8", amd::GPU_Library_HSAIL, CARRIZO_A0,      F_VI_BASE, true, true,  FAMILY_CZ, false },
-  { "VI", "Fiji",      "GFX8", amd::GPU_Library_HSAIL, VI_FIJI_P_A0,    F_VI_BASE, true, true,  FAMILY_VI, false },
-  { "CZ", "Stoney",    "GFX8", amd::GPU_Library_HSAIL, STONEY_A0,       F_VI_BASE, true, true,  FAMILY_CZ, false },
-  { "VI", "Baffin",    "GFX8", amd::GPU_Library_HSAIL, VI_BAFFIN_M_A0,  F_VI_BASE, true, false, FAMILY_VI, false },
-  { "VI", "Baffin",    "GFX8", amd::GPU_Library_HSAIL, VI_BAFFIN_M_A1,  F_VI_BASE, true, true,  FAMILY_VI, false },
-  { "VI", "Ellesmere", "GFX8", amd::GPU_Library_HSAIL, VI_ELLESMERE_P_A0, F_VI_BASE, true, false, FAMILY_VI, false },
-  { "VI", "Ellesmere", "GFX8", amd::GPU_Library_HSAIL, VI_ELLESMERE_P_A1, F_VI_BASE, true, true,  FAMILY_VI, false },
-#ifndef BRAHMA
-  { "AI", "gfx900",    "GFX9", amd::GPU_Library_HSAIL, AI_GREENLAND_P_A0, F_AI_BASE, true, false,  FAMILY_AI },
-  { "AI", "gfx900",    "GFX9", amd::GPU_Library_HSAIL, AI_GREENLAND_P_A1, F_AI_BASE, true, true,  FAMILY_AI },
-#else
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  { "VI", "gfx804",    "GFX8", amd::GPU_Library_HSAIL, VI_LEXA_V_A0,      F_VI_BASE, true, true,  FAMILY_VI },
-#ifndef BRAHMA
-  { "AI", "gfx901",    "GFX9", amd::GPU_Library_HSAIL, AI_GREENLAND_P_A0, F_AI_BASE, true, false,  FAMILY_AI ,true },
-  { "AI", "gfx901",    "GFX9", amd::GPU_Library_HSAIL, AI_GREENLAND_P_A1, F_AI_BASE, true, true,  FAMILY_AI ,true },
-  { "RV", "gfx902",    "GFX9",  amd::GPU_Library_HSAIL, RAVEN_A0,           F_AI_BASE, true, true,  FAMILY_RV, false },
-  { "RV", "gfx903",    "GFX9",  amd::GPU_Library_HSAIL, RAVEN_A0,           F_AI_BASE, true, true,  FAMILY_RV, true },
-  { "AI", "gfx904",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA12_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, false },
-  { "AI", "gfx905",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA12_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, true },
-  { "AI", "gfx906",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA20_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, false },
-  { "AI", "gfx907",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA20_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, true },
-#else
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  InvalidTarget
-};
-
-#endif // _CL_UTILS_TARGET_MAPPINGS_HSAIL_0_8_H_
diff --git a/compiler/lib/utils/v0_8/target_mappings_hsail64.h b/compiler/lib/utils/v0_8/target_mappings_hsail64.h
deleted file mode 100644
index 0be0ce9..0000000
--- a/compiler/lib/utils/v0_8/target_mappings_hsail64.h
+++ /dev/null
@@ -1,69 +0,0 @@
-//
-// Copyright (c) 2012 Advanced Micro Devices, Inc. All rights reserved.
-//
-#ifndef _CL_UTILS_TARGET_MAPPINGS_HSAIL64_0_8_H_
-#define _CL_UTILS_TARGET_MAPPINGS_HSAIL64_0_8_H_
-
-#include "si_id.h"
-#include "kv_id.h"
-#include "ci_id.h"
-#include "ai_id.h"
-#include "rv_id.h"
-#include "atiid.h"
-
-static const TargetMapping HSAIL64TargetMapping_0_8[] = {
-  UnknownTarget,
-  { "KV", "Spectre",   "GFX7", amd::GPU_Library_HSAIL, KV_SPECTRE_A0,   F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "KV", "Spooky",    "GFX7", amd::GPU_Library_HSAIL, KV_SPOOKY_A0,    F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "KV", "Kalindi",   "GFX7", amd::GPU_Library_HSAIL, KB_KALINDI_A0,   F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "KV", "Mullins",   "GFX7", amd::GPU_Library_HSAIL, ML_GODAVARI_A0,  F_CI_BASE, true, true,  FAMILY_KV, false },
-  { "CI", "Bonaire",   "GFX7", amd::GPU_Library_HSAIL, CI_BONAIRE_M_A0, F_CI_BASE, true, false, FAMILY_CI, false },
-  { "CI", "Bonaire",   "GFX7", amd::GPU_Library_HSAIL, CI_BONAIRE_M_A1, F_CI_BASE, true, true,  FAMILY_CI, false },
-  { "CI", "Hawaii",    "GFX7", amd::GPU_Library_HSAIL, CI_HAWAII_P_A0,  F_CI_BASE, true, true,  FAMILY_CI, false },
-  { "VI", "Iceland",   "GFX8", amd::GPU_Library_HSAIL, VI_ICELAND_M_A0, F_VI_BASE, true, true,  FAMILY_VI, false },
-  { "VI", "Tonga",     "GFX8", amd::GPU_Library_HSAIL, VI_TONGA_P_A0,   F_VI_BASE, true, true,  FAMILY_VI, false },
-#ifndef OPENCL_MAINLINE
-  { "CI", "Tiran",     "GFX7", amd::GPU_Library_HSAIL, CI_TIRAN_P_A0,   F_CI_BASE, true, true,  FAMILY_CI, false },
-  { "CI", "Maui",      "GFX7", amd::GPU_Library_HSAIL, CI_MAUI_P_A0,    F_CI_BASE, true, true,  FAMILY_CI, false },
-#else
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  { "CZ", "Carrizo",   "GFX8", amd::GPU_Library_HSAIL, CARRIZO_A0,      F_VI_BASE, true, true,  FAMILY_CZ, false },
-  { "VI", "Fiji",      "GFX8", amd::GPU_Library_HSAIL, VI_FIJI_P_A0,    F_VI_BASE, true, true,  FAMILY_VI, false },
-  { "CZ", "Stoney",    "GFX8", amd::GPU_Library_HSAIL, STONEY_A0,       F_VI_BASE, true, true,  FAMILY_CZ, false },
-  { "VI", "Baffin",    "GFX8", amd::GPU_Library_HSAIL, VI_BAFFIN_M_A0,  F_VI_BASE, true, false, FAMILY_VI, false },
-  { "VI", "Baffin",    "GFX8", amd::GPU_Library_HSAIL, VI_BAFFIN_M_A1,  F_VI_BASE, true, true,  FAMILY_VI, false },
-  { "VI", "Ellesmere", "GFX8", amd::GPU_Library_HSAIL, VI_ELLESMERE_P_A0, F_VI_BASE, true, false, FAMILY_VI, false },
-  { "VI", "Ellesmere", "GFX8", amd::GPU_Library_HSAIL, VI_ELLESMERE_P_A1, F_VI_BASE, true, true,  FAMILY_VI, false },
-#ifndef BRAHMA
-  { "AI", "gfx900",    "GFX9", amd::GPU_Library_HSAIL, AI_GREENLAND_P_A0, F_AI_BASE, true, false,  FAMILY_AI, false },
-  { "AI", "gfx900",    "GFX9", amd::GPU_Library_HSAIL, AI_GREENLAND_P_A1, F_AI_BASE, true, true,  FAMILY_AI, false },
-#else
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  { "VI", "gfx804",    "GFX8", amd::GPU_Library_HSAIL, VI_LEXA_V_A0,      F_VI_BASE, true, true,  FAMILY_VI, false },
-#ifndef BRAHMA
-  { "AI", "gfx901",    "GFX9",  amd::GPU_Library_HSAIL, AI_GREENLAND_P_A0,  F_AI_BASE, true, false,  FAMILY_AI, true },
-  { "AI", "gfx901",    "GFX9",  amd::GPU_Library_HSAIL, AI_GREENLAND_P_A1,  F_AI_BASE, true, true,  FAMILY_AI, true },
-  { "RV", "gfx902",    "GFX9",  amd::GPU_Library_HSAIL, RAVEN_A0,           F_AI_BASE, true, true,  FAMILY_RV, false },
-  { "RV", "gfx903",    "GFX9",  amd::GPU_Library_HSAIL, RAVEN_A0,           F_AI_BASE, true, true,  FAMILY_RV, true },
-  { "AI", "gfx904",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA12_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, false },
-  { "AI", "gfx905",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA12_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, true },
-  { "AI", "gfx906",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA20_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, false },
-  { "AI", "gfx907",    "GFX9",  amd::GPU_Library_HSAIL, AI_VEGA20_P_A0,     F_AI_BASE, true, true,  FAMILY_AI, true },
-#else
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-  UnknownTarget,
-#endif
-  InvalidTarget
-};
-
-#endif // _CL_UTILS_TARGET_MAPPINGS_HSAIL64_0_8_H_
diff --git a/compiler/lib/utils/v0_8/target_mappings_x64.h b/compiler/lib/utils/v0_8/target_mappings_x64.h
deleted file mode 100644
index ebe5a83..0000000
--- a/compiler/lib/utils/v0_8/target_mappings_x64.h
+++ /dev/null
@@ -1,46 +0,0 @@
-//
-// Copyright (c) 2012 Advanced Micro Devices, Inc. All rights reserved.
-//
-#ifndef _CL_UTILS_TARGET_MAPPINGS_X64_0_8_H_
-#define _CL_UTILS_TARGET_MAPPINGS_X64_0_8_H_
-
-#define CPU_MAPPING_LIB(A, B, C, D, E) { #A, #B, #C, D, 0, E, LP64_SWITCH(false, true), LP64_SWITCH(false, true), FAMILY_X64}
-#define CPU_MAPPING(A, B, C, D) CPU_MAPPING_LIB(A, B, C, amd::CPU64_Library_Generic, D)
-#define NCPU_MAPPING_LIB(A, B, C, D, E) { #A, #B, #C, D, 0, E, false, false, FAMILY_X64}
-#define NCPU_MAPPING(A, B, C, D) { #A, #B, #C, amd::CPU64_Library_Generic, 0, D, false, false, FAMILY_X64}
-static const TargetMapping X64TargetMapping_0_8[] = {
-  UnknownTarget,
-  CPU_MAPPING(X64,         Generic,     generic, 0x1),
-  CPU_MAPPING(NetBurst,    Prescott,    prescott, 0x1),
-  CPU_MAPPING(Xeon,        Nocona,      nocona, 0x1),
-  CPU_MAPPING(Core,        Core2,       core2, 0x1),
-  CPU_MAPPING(Core,        Penryn,      penryn, 0x1),
-  CPU_MAPPING(Nehalem,     Corei7,      corei7, 0x1),
-  CPU_MAPPING(Nehalem,     Nehalem,     nehalem, 0x1),
-  CPU_MAPPING(Nehalem,     Westmere,    westmere, 0x1),
-  NCPU_MAPPING_LIB(SandyBridge, Corei7_AVX,  sandybridge, amd::CPU64_Library_AVX, 0x2 | 0x1),  // LLVM 2.9 only
-  CPU_MAPPING_LIB(SandyBridge, Corei7_AVX,  corei7-avx, amd::CPU64_Library_AVX, 0x2 | 0x1),
-  CPU_MAPPING(SandyBridge, IvyBridge,   core-avx-i, 0x2 | 0x1), // LLVM 3.0
-  CPU_MAPPING(Haswell,     Haswell,     core-avx2, 0x4 | 0x2 | 0x1), // LLVM 3.0
-  CPU_MAPPING(K8,          K8,          k8, 0x1),
-  CPU_MAPPING(K8,          Opteron,     opteron, 0x1),
-  CPU_MAPPING(K8,          Athlon64,    athlon64, 0x1),
-  CPU_MAPPING(K8,          AthlonFX,    athlon-fx, 0x1),
-  CPU_MAPPING(K8,          K8_SSE3,     k8-sse3, 0x1),
-  CPU_MAPPING(K8,          Opteron_SSE3,opteron-sse3, 0x1),
-  CPU_MAPPING(K8,          Athlon64SSE3,athlon64-sse3, 0x1),
-  CPU_MAPPING(K10,         AMDFAM10,    amdfam10, 0x1),
-  NCPU_MAPPING(K10,         Barcelona,  barcelona, 0x1),
-  NCPU_MAPPING(K10,         Istanbul,    istanbul, 0x1),
-  NCPU_MAPPING(K10,         Shanghai,    shanghai, 0x1),
-  CPU_MAPPING(Family14h,   Bobcat, btver1, 0x1),
-  CPU_MAPPING_LIB(Family15h, Bulldozer, bdver1, amd::CPU64_Library_FMA4, 0x8 | 0x1),
-  CPU_MAPPING_LIB(Family15h, Piledriver, bdver2, amd::CPU64_Library_FMA4, 0x8 | 0x4 | 0x1),
-  CPU_MAPPING(Atom, Atom, atom, 0x1),
-  InvalidTarget
-};
-#undef CPU_MAPPING
-#undef NCPU_MAPPING
-#undef CPU_MAPPING_LIB
-#undef NCPU_MAPPING_LIB
-#endif // _CL_UTILS_TARGET_MAPPINGS_X64_0_8_H_
diff --git a/compiler/lib/utils/v0_8/target_mappings_x86.h b/compiler/lib/utils/v0_8/target_mappings_x86.h
deleted file mode 100644
index 979c6e3..0000000
--- a/compiler/lib/utils/v0_8/target_mappings_x86.h
+++ /dev/null
@@ -1,73 +0,0 @@
-//
-// Copyright (c) 2012 Advanced Micro Devices, Inc. All rights reserved.
-//
-#ifndef _CL_UTILS_TARGET_MAPPINGS_X86_0_8_H_
-#define _CL_UTILS_TARGET_MAPPINGS_X86_0_8_H_
-#define CPU_MAPPING_LIB(A, B, C, D, E) { #A, #B, #C, D, 0, E, true, true, FAMILY_X86}
-#define CPU_MAPPING(A, B, C, D) CPU_MAPPING_LIB(A, B, C, amd::CPU_Library_Generic, D)
-#define NCPU_MAPPING_LIB(A, B, C, D, E) { #A, #B, #C, D, 0, E, false, false, FAMILY_X86}
-#define NCPU_MAPPING(A, B, C, D) { #A, #B, #C, amd::CPU_Library_Generic, 0, D, false, false, FAMILY_X86}
-static const TargetMapping X86TargetMapping_0_8[] = {
-  UnknownTarget,
-  CPU_MAPPING(X86,         Generic,     generic, 0),
-  // This has to be specified manually since GCC defines i386 as a macro.
-  { "X86", "i386", "i386", amd::CPU_Library_Generic, 0, 0, true, true, FAMILY_X86 },
-  CPU_MAPPING(X86,         i486,        i486, 0),
-  CPU_MAPPING(X86,         i586,        i586, 0),
-  CPU_MAPPING(Pentium,     Pentium,     pentium, 0),
-  CPU_MAPPING(Pentium_MMX, Pentium_MMX, pentium-mmx, 0),
-  CPU_MAPPING(X86,         i686,        i686, 0),
-  CPU_MAPPING(PentiumPro,  PentiumPro,  pentiumpro, 0),
-  CPU_MAPPING(Pentium2,    Pentium2,    pentium2, 0),
-  CPU_MAPPING(Pentium3,    Pentium3,    pentium3, 0),
-  CPU_MAPPING(Pentium3m,   Pentium3m,   pentium3m, 0),
-  CPU_MAPPING(Pentium_M,   Pentium_M,   pentium-m, 0x1),
-  CPU_MAPPING(NetBurst,    Pentium4,    pentium4, 0x1),
-  CPU_MAPPING(NetBurst,    Pentium4m,   pentium4m, 0x1),
-  CPU_MAPPING(Pentium_M,   Yonah,       yonah, 0x1),
-  CPU_MAPPING(Pentium4,    Prescott,    prescott, 0x1),
-  CPU_MAPPING(Xeon,        Nocona,      nocona, 0x1),
-  CPU_MAPPING(Core,        Core2,       core2, 0x1),
-  CPU_MAPPING(Core,        Penryn,      penryn, 0x1),
-  CPU_MAPPING(Nehalem,     Corei7,      corei7, 0x1), // Corei3 and Corei5 also
-  CPU_MAPPING(Nehalem,     Nehalem,     nehalem, 0x1),
-  CPU_MAPPING(Nehalem,     Westmere,    westmere, 0x1),
-  NCPU_MAPPING_LIB(SandyBridge, Corei7_AVX,  sandybridge, amd::CPU64_Library_AVX, 0x2 | 0x1),  // LLVM 2.9 only
-  CPU_MAPPING(SandyBridge, Corei7_AVX,  corei7-avx, 0x2 | 0x1), // LLVM 3.0 only
-  CPU_MAPPING(SandyBridge, IvyBridge,   core-avx-i, 0x2 | 0x1), // LLVM 3.0 only
-  CPU_MAPPING(Haswell,     Haswell,     core-avx2, 0x4 | 0x2 | 0x1), // LLVM 3.0 only
-  CPU_MAPPING(K6,          K6,          k6, 0),
-  CPU_MAPPING(K6,          K6_2,        k6-2, 0),
-  CPU_MAPPING(K6,          K6_3,        k6-3, 0),
-  CPU_MAPPING(K7,          Athlon,      athlon, 0),
-  CPU_MAPPING(K7,          AthlonTBIRD, athlon-tbird, 0),
-  CPU_MAPPING(K7,          Athlon4,     athlon-4, 0),
-  CPU_MAPPING(K7,          AthlonXP,    athlon-xp, 0),
-  CPU_MAPPING(K7,          AthlonMP,    athlon-mp, 0),
-  CPU_MAPPING(K8,          K8,          k8, 0x1),
-  CPU_MAPPING(K8,          Opteron,     opteron, 0x1),
-  CPU_MAPPING(K8,          Athlon64,    athlon64, 0x1),
-  CPU_MAPPING(K8,          AthlonFX,    athlon-fx, 0x1),
-  CPU_MAPPING(K8,          K8_SSE3,     k8-sse3, 0x1),
-  CPU_MAPPING(K8,          Opteron_SSE3,opteron-sse3, 0x1),
-  CPU_MAPPING(K8,          Athlon64SSE3,athlon64-sse3, 0x1),
-  CPU_MAPPING(K10,         AMDFAM10,    amdfam10, 0x1),
-  NCPU_MAPPING(K10,        Barcelona,   barcelona, 0x1),
-  NCPU_MAPPING(K10,        Istanbul,    istanbul, 0x1),
-  NCPU_MAPPING(K10,        Shanghai,    shanghai, 0x1),
-  CPU_MAPPING(Winchip,     Winchip_C6,  winchip-c6, 0),
-  CPU_MAPPING(Winchip,     Winchip2,    winchip2, 0),
-  CPU_MAPPING(Via,         C3,          c3, 0),
-  CPU_MAPPING(Via,         C3_2,        c3-2, 0),
-  CPU_MAPPING(Family14h,   Bobcat,      btver1, 0x1), // LLVM 3.1 only
-  CPU_MAPPING_LIB(Family15h, Bulldozer, bdver1, amd::CPU_Library_FMA4, 0x8 | 0x1), // LLVM 3.1 only
-  CPU_MAPPING_LIB(Family15h, Piledriver, bdver2, amd::CPU_Library_FMA4, 0x8 | 0x4 | 0x1), // LLVM 3.1 only
-  CPU_MAPPING(Atom,        Atom,        atom, 0x1), // LLVM 3.1 only
-  InvalidTarget
-};
-#undef CPU_MAPPING
-#undef NCPU_MAPPING
-#undef CPU_MAPPING_LIB
-#undef NCPU_MAPPING_LIB
-
-#endif // _CL_UTILS_TARGET_MAPPINGS_X86_0_8_H_
diff --git a/runtime/CMakeLists.txt b/runtime/CMakeLists.txt
index 0a55cf5..2c9dfd6 100644
--- a/runtime/CMakeLists.txt
+++ b/runtime/CMakeLists.txt
@@ -8,13 +8,21 @@ if(CMAKE_BUILD_TYPE MATCHES "^Debug$")
 endif()
 
 include_directories(${ROCR_INCLUDES})
+if (DEFINED LLVM_INCLUDES AND NOT ${LLVM_INCLUDES} STREQUAL "")
+  include_directories(${LLVM_INCLUDES})
+endif() # if (DEFINED LLVM_INCLUDES AND NOT ${LLVM_INCLUDES} STREQUAL "")
 
 include_directories(${CMAKE_SOURCE_DIR}/runtime)
 include_directories(${CMAKE_SOURCE_DIR}/api/opencl)
 include_directories(${CMAKE_SOURCE_DIR}/api/opencl/khronos)
 include_directories(${CMAKE_SOURCE_DIR}/api/opencl/khronos/headers)
 include_directories(${CMAKE_SOURCE_DIR}/api/opencl/khronos/headers/opencl2.2)
-include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/include)
+
+# FIXME: Remove following if block after enabling COMGR by default
+if (${USE_COMGR_LIBRARY} STREQUAL "no")
+  include_directories(${CMAKE_SOURCE_DIR}/compiler/llvm/include)
+endif() # if (${USE_COMGR_LIBRARY} STREQUAL "no")
+
 include_directories(${CMAKE_SOURCE_DIR}/compiler/driver/src)
 include_directories(${CMAKE_SOURCE_DIR}/compiler/lib)
 include_directories(${CMAKE_SOURCE_DIR}/compiler/lib/include)
diff --git a/runtime/device/comgrctx.cpp b/runtime/device/comgrctx.cpp
index 6edcfc1..51ffcbf 100644
--- a/runtime/device/comgrctx.cpp
+++ b/runtime/device/comgrctx.cpp
@@ -15,8 +15,8 @@ bool Comgr::LoadLib() {
 #if defined(COMGR_DYN_DLL)
   LogInfo("Loading COMGR library.");
   static const char* ComgrLibName =
-    LP64_SWITCH(WINDOWS_SWITCH("amdcomgr.dll", "libamdcomgr32.so"),
-                WINDOWS_SWITCH("amdcomgr64.dll", "libamdcomgr64.so"));
+    LP64_SWITCH(WINDOWS_SWITCH("amdcomgr.dll", "libamd_comgr32.so"),
+                WINDOWS_SWITCH("amdcomgr64.dll", "libamd_comgr.so"));
   cep_.handle = Os::loadLibrary(ComgrLibName);
   if (nullptr == cep_.handle) {
     return false;
diff --git a/runtime/device/devprogram.cpp b/runtime/device/devprogram.cpp
index c797f98..587e950 100644
--- a/runtime/device/devprogram.cpp
+++ b/runtime/device/devprogram.cpp
@@ -706,7 +706,7 @@ bool Program::compileImplLC(const std::string& sourceCode,
   driverOptions.push_back("-amdgpu-prelink");
 
   if (device().settings().lcWavefrontSize64_) {
-     driverOptions.append(" -mwavefrontsize64");
+     driverOptions.push_back("-mwavefrontsize64");
   }
 
   // Iterate through each source code and dump it into tmp
@@ -1547,7 +1547,7 @@ bool Program::linkImplLC(amd::option::Options* options) {
 #endif
 
   if (device().settings().lcWavefrontSize64_) {
-     codegenOptions.append(" -mwavefrontsize64");
+     codegenOptions.push_back("-mwavefrontsize64");
   }
 
   // NOTE: The params is also used to identy cached code object. This parameter
diff --git a/runtime/device/rocm/CMakeLists.txt b/runtime/device/rocm/CMakeLists.txt
index 7dce5b9..5870b65 100644
--- a/runtime/device/rocm/CMakeLists.txt
+++ b/runtime/device/rocm/CMakeLists.txt
@@ -29,80 +29,83 @@ add_library(oclrocm OBJECT
 )
 set_target_properties(oclrocm PROPERTIES POSITION_INDEPENDENT_CODE ON)
 
-# generating libraries.amdgcn.inc
-file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc "// Automatically generated file; DO NOT EDIT.\n")
+# FIXME: Remove following if block after enabling COMGR by default
+if (${USE_COMGR_LIBRARY} STREQUAL "no")
+  # generating libraries.amdgcn.inc
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc "// Automatically generated file; DO NOT EDIT.\n")
 
-foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
-  get_target_property(lib_file ${AMDGCN_LIB_TARGET} OUTPUT_NAME)
-  get_target_property(lib_file_name ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_NAME)
-  get_target_property(lib_file_path ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_DIRECTORY)
-  set(bclib "${lib_file}")
-  set(header "${lib_file_name}.${INC_SUFFIX}")
-  set(symbol "${lib_file_name}_lib")
-  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${header}
-    COMMAND bc2h ${bclib} ${CMAKE_CURRENT_BINARY_DIR}/${header} ${symbol}
-    DEPENDS bc2h ${AMDGCN_LIB_TARGET}
-    COMMENT "Generating ${header}"
-  )
-  set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_BINARY_DIR}/${target}.inc)
+  foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
+    get_target_property(lib_file ${AMDGCN_LIB_TARGET} OUTPUT_NAME)
+    get_target_property(lib_file_name ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_NAME)
+    get_target_property(lib_file_path ${AMDGCN_LIB_TARGET} ARCHIVE_OUTPUT_DIRECTORY)
+    set(bclib "${lib_file}")
+    set(header "${lib_file_name}.${INC_SUFFIX}")
+    set(symbol "${lib_file_name}_lib")
+    add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${header}
+      COMMAND bc2h ${bclib} ${CMAKE_CURRENT_BINARY_DIR}/${header} ${symbol}
+      DEPENDS bc2h ${AMDGCN_LIB_TARGET}
+      COMMENT "Generating ${header}"
+    )
+    set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_BINARY_DIR}/${target}.inc)
 
-  add_custom_target(${header}_target ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${header})
-  add_dependencies(oclrocm  ${header}_target)
+    add_custom_target(${header}_target ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${header})
+    add_dependencies(oclrocm  ${header}_target)
 
-  file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc "#include \"${header}\"\n")
-endforeach()
+    file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc "#include \"${header}\"\n")
+  endforeach()
 
-# Generate function to select libraries for a given GFXIP number.
-file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
-  "static inline std::tuple<const char*, const void*, size_t> get_oclc_isa_version(uint gfxip) { \
-   switch (gfxip) {\n")
-foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
-  if (${AMDGCN_LIB_TARGET} MATCHES "^oclc_isa_version_[0-9]+_lib$")
-    string(REGEX REPLACE "^oclc_isa_version_([0-9]+)_lib$" "\\1" gfxip ${AMDGCN_LIB_TARGET})
-    file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
-      "case ${gfxip}: return std::make_tuple( \"oclc_isa_version_${gfxip}_lib.bc\","
-                "  oclc_isa_version_${gfxip}_lib, oclc_isa_version_${gfxip}_lib_size); break;\n")
-  endif()
-endforeach()
-file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
-  "default: return std::make_tuple(\"\",(const void*)0,(size_t)0); }\n}\n")
+  # Generate function to select libraries for a given GFXIP number.
+  file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
+    "static inline std::tuple<const char*, const void*, size_t> get_oclc_isa_version(uint gfxip) { \
+     switch (gfxip) {\n")
+  foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
+    if (${AMDGCN_LIB_TARGET} MATCHES "^oclc_isa_version_[0-9]+_lib$")
+      string(REGEX REPLACE "^oclc_isa_version_([0-9]+)_lib$" "\\1" gfxip ${AMDGCN_LIB_TARGET})
+      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
+        "case ${gfxip}: return std::make_tuple( \"oclc_isa_version_${gfxip}_lib.bc\","
+                  "  oclc_isa_version_${gfxip}_lib, oclc_isa_version_${gfxip}_lib_size); break;\n")
+    endif()
+  endforeach()
+  file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
+    "default: return std::make_tuple(\"\",(const void*)0,(size_t)0); }\n}\n")
 
-foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
-  if (${AMDGCN_LIB_TARGET} MATCHES "oclc_(.*)_on_lib")
-    string(REGEX REPLACE "oclc_(.*)_on_lib" "\\1" function ${AMDGCN_LIB_TARGET})
-    file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
-      "static inline std::tuple<const char*,const void*,size_t>  get_oclc_${function}(bool on)"
-                " { return std::make_tuple(  on ? \"oclc_${function}_on_lib.bc\" : \"oclc_${function}_off_lib.bc\","
-                "  (const void*)(on ? oclc_${function}_on_lib : oclc_${function}_off_lib),"
-                " on ? oclc_${function}_on_lib_size : oclc_${function}_off_lib_size);  }\n")
-  endif()
-endforeach()
+  foreach(AMDGCN_LIB_TARGET ${AMDGCN_LIB_TARGETS})
+    if (${AMDGCN_LIB_TARGET} MATCHES "oclc_(.*)_on_lib")
+      string(REGEX REPLACE "oclc_(.*)_on_lib" "\\1" function ${AMDGCN_LIB_TARGET})
+      file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libraries.amdgcn.inc
+        "static inline std::tuple<const char*,const void*,size_t>  get_oclc_${function}(bool on)"
+                  " { return std::make_tuple(  on ? \"oclc_${function}_on_lib.bc\" : \"oclc_${function}_off_lib.bc\","
+                  "  (const void*)(on ? oclc_${function}_on_lib : oclc_${function}_off_lib),"
+                  " on ? oclc_${function}_on_lib_size : oclc_${function}_off_lib_size);  }\n")
+    endif()
+  endforeach()
 
-# generating opencl*.inc files
-add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch
-  COMMAND clang -cc1 -x cl-header -triple amdgcn-amd-amdhsa -Werror -O3 -DNDEBUG -cl-std=CL1.2 -emit-pch -o ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch < ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
-  DEPENDS clang ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
-  COMMENT "Generating opencl1.2-c.amdgcn.pch"
-)
-add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc
-  COMMAND bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc opencl1_2_c
-  DEPENDS bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch
-  COMMENT "Generating opencl1.2-c.amdgcn.inc"
-)
-set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch)
-add_custom_target(opencl1.2-c.amdgcn.inc_target ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc)
-add_dependencies(oclrocm opencl1.2-c.amdgcn.inc_target)
+  # generating opencl*.inc files
+  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch
+    COMMAND clang -cc1 -x cl-header -triple amdgcn-amd-amdhsa -Werror -O3 -DNDEBUG -cl-std=CL1.2 -emit-pch -o ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch < ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
+    DEPENDS clang ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
+    COMMENT "Generating opencl1.2-c.amdgcn.pch"
+  )
+  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc
+    COMMAND bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc opencl1_2_c
+    DEPENDS bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch
+    COMMENT "Generating opencl1.2-c.amdgcn.inc"
+  )
+  set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.pch)
+  add_custom_target(opencl1.2-c.amdgcn.inc_target ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/opencl1.2-c.amdgcn.inc)
+  add_dependencies(oclrocm opencl1.2-c.amdgcn.inc_target)
 
-add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch
-  COMMAND clang -cc1 -x cl-header -triple amdgcn-amd-amdhsa -Werror -O3 -DNDEBUG -cl-std=CL2.0 -emit-pch -o ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch < ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
-  DEPENDS clang ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
-  COMMENT "Generating opencl2.0-c.amdgcn.pch"
-)
-add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc
-  COMMAND bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc opencl2_0_c
-  DEPENDS bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch
-  COMMENT "Generating opencl2.0-c.amdgcn.inc"
-)
-set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch)
-add_custom_target(opencl2.0-c.amdgcn.inc_target ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc)
-add_dependencies(oclrocm opencl2.0-c.amdgcn.inc_target)
+  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch
+    COMMAND clang -cc1 -x cl-header -triple amdgcn-amd-amdhsa -Werror -O3 -DNDEBUG -cl-std=CL2.0 -emit-pch -o ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch < ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
+    DEPENDS clang ${CMAKE_SOURCE_DIR}/compiler/llvm/tools/clang/lib/Headers/opencl-c.h
+    COMMENT "Generating opencl2.0-c.amdgcn.pch"
+  )
+  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc
+    COMMAND bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc opencl2_0_c
+    DEPENDS bc2h ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch
+    COMMENT "Generating opencl2.0-c.amdgcn.inc"
+  )
+  set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.pch)
+  add_custom_target(opencl2.0-c.amdgcn.inc_target ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/opencl2.0-c.amdgcn.inc)
+  add_dependencies(oclrocm opencl2.0-c.amdgcn.inc_target)
+endif() # if (${USE_COMGR_LIBRARY} STREQUAL "no")
diff --git a/runtime/device/rocm/rocprogram.cpp b/runtime/device/rocm/rocprogram.cpp
index 191e58c..0155dc2 100644
--- a/runtime/device/rocm/rocprogram.cpp
+++ b/runtime/device/rocm/rocprogram.cpp
@@ -9,9 +9,9 @@
 #include "rockernel.hpp"
 #if defined(WITH_LIGHTNING_COMPILER) || defined(USE_COMGR_LIBRARY)
 #include <gelf.h>
-#include "libraries.amdgcn.inc"
 #ifndef USE_COMGR_LIBRARY
 #include "driver/AmdCompiler.h"
+#include "libraries.amdgcn.inc"
 #endif
 #endif  // defined(WITH_LIGHTNING_COMPILER) || defined(USE_COMGR_LIBRARY)
 
diff --git a/runtime/platform/object.hpp b/runtime/platform/object.hpp
index 8ab1b68..e71948f 100644
--- a/runtime/platform/object.hpp
+++ b/runtime/platform/object.hpp
@@ -9,7 +9,6 @@
 #include "os/alloc.hpp"
 #include "thread/monitor.hpp"
 #include "utils/util.hpp"
-#include <icd/icd_dispatch.h>
 
 
 #define KHR_CL_TYPES_DO(F)                                                                         \
diff --git a/tools/clinfo/CMakeLists.txt b/tools/clinfo/CMakeLists.txt
index 974a46f..f4b30b2 100644
--- a/tools/clinfo/CMakeLists.txt
+++ b/tools/clinfo/CMakeLists.txt
@@ -2,12 +2,10 @@ set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
 
 set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
 
-include_directories(${OPENCL_INCLUDE_DIRS})
+include_directories(${OPENCL_ICD_LOADER_HEADERS_DIR})
 
 add_definitions(-DHAVE_CL2_HPP)
 
 add_executable(clinfo clinfo.cpp)
 
 target_link_libraries(clinfo OpenCL)
-
-install(TARGETS clinfo DESTINATION bin)
